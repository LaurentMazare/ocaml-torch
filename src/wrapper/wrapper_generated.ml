(* THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT BY HAND! *)

open Ctypes
module C = Torch_bindings.C (Torch_generated)
open C.TensorG

let to_tensor_list ptr =
  let rec loop ptr acc =
    let tensor = !@ptr in
    if is_null tensor
    then acc
    else (
      Gc.finalise C.Tensor.free tensor;
      loop (ptr +@ 1) (tensor :: acc))
  in
  let result = loop ptr [] in
  C.free (to_voidp ptr);
  List.rev result

let __and__ self other =
  let out__ = CArray.make t 1 in
  stubs___and__ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let __iand__ self other =
  let out__ = CArray.make t 1 in
  stubs___iand__ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let __ilshift__ self other =
  let out__ = CArray.make t 1 in
  stubs___ilshift__ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let __ior__ self other =
  let out__ = CArray.make t 1 in
  stubs___ior__ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let __irshift__ self other =
  let out__ = CArray.make t 1 in
  stubs___irshift__ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let __ixor__ self other =
  let out__ = CArray.make t 1 in
  stubs___ixor__ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let __lshift__ self other =
  let out__ = CArray.make t 1 in
  stubs___lshift__ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let __or__ self other =
  let out__ = CArray.make t 1 in
  stubs___or__ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let __rshift__ self other =
  let out__ = CArray.make t 1 in
  stubs___rshift__ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let __xor__ self other =
  let out__ = CArray.make t 1 in
  stubs___xor__ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _adaptive_avg_pool2d self ~output_size =
  let out__ = CArray.make t 1 in
  stubs__adaptive_avg_pool2d
    (CArray.start out__)
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _adaptive_avg_pool2d_backward ~grad_output self =
  let out__ = CArray.make t 1 in
  stubs__adaptive_avg_pool2d_backward (CArray.start out__) grad_output self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _adaptive_avg_pool3d self ~output_size =
  let out__ = CArray.make t 1 in
  stubs__adaptive_avg_pool3d
    (CArray.start out__)
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _adaptive_avg_pool3d_backward ~grad_output self =
  let out__ = CArray.make t 1 in
  stubs__adaptive_avg_pool3d_backward (CArray.start out__) grad_output self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _add_batch_dim self ~batch_dim ~level =
  let out__ = CArray.make t 1 in
  stubs__add_batch_dim
    (CArray.start out__)
    self
    (Int64.of_int batch_dim)
    (Int64.of_int level);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _add_relu self other =
  let out__ = CArray.make t 1 in
  stubs__add_relu (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _add_relu_ self other =
  let out__ = CArray.make t 1 in
  stubs__add_relu_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _add_relu_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs__add_relu_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _aminmax self =
  let out__ = CArray.make t 2 in
  stubs__aminmax (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let _aminmax1 self ~dim ~keepdim =
  let out__ = CArray.make t 2 in
  stubs__aminmax1 (CArray.start out__) self (Int64.of_int dim) (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let _amp_update_scale_
    self
    ~growth_tracker
    ~found_inf
    ~scale_growth_factor
    ~scale_backoff_factor
    ~growth_interval
  =
  let out__ = CArray.make t 1 in
  stubs__amp_update_scale_
    (CArray.start out__)
    self
    growth_tracker
    found_inf
    scale_growth_factor
    scale_backoff_factor
    (Int64.of_int growth_interval);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _baddbmm_mkl_ self ~batch1 ~batch2 =
  let out__ = CArray.make t 1 in
  stubs__baddbmm_mkl_ (CArray.start out__) self batch1 batch2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _bmm self ~mat2 ~deterministic =
  let out__ = CArray.make t 1 in
  stubs__bmm (CArray.start out__) self mat2 (if deterministic then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _bmm_out ~out self ~mat2 ~deterministic =
  let out__ = CArray.make t 1 in
  stubs__bmm_out (CArray.start out__) out self mat2 (if deterministic then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _cast_byte self ~non_blocking =
  let out__ = CArray.make t 1 in
  stubs__cast_byte (CArray.start out__) self (if non_blocking then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _cast_char self ~non_blocking =
  let out__ = CArray.make t 1 in
  stubs__cast_char (CArray.start out__) self (if non_blocking then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _cast_double self ~non_blocking =
  let out__ = CArray.make t 1 in
  stubs__cast_double (CArray.start out__) self (if non_blocking then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _cast_float self ~non_blocking =
  let out__ = CArray.make t 1 in
  stubs__cast_float (CArray.start out__) self (if non_blocking then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _cast_half self ~non_blocking =
  let out__ = CArray.make t 1 in
  stubs__cast_half (CArray.start out__) self (if non_blocking then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _cast_int self ~non_blocking =
  let out__ = CArray.make t 1 in
  stubs__cast_int (CArray.start out__) self (if non_blocking then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _cast_long self ~non_blocking =
  let out__ = CArray.make t 1 in
  stubs__cast_long (CArray.start out__) self (if non_blocking then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _cast_short self ~non_blocking =
  let out__ = CArray.make t 1 in
  stubs__cast_short (CArray.start out__) self (if non_blocking then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _cat tensors ~dim =
  let out__ = CArray.make t 1 in
  stubs__cat
    (CArray.start out__)
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors)
    (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _cat_out ~out tensors ~dim =
  let out__ = CArray.make t 1 in
  stubs__cat_out
    (CArray.start out__)
    out
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors)
    (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _cdist_backward ~grad ~x1 ~x2 ~p ~cdist =
  let out__ = CArray.make t 1 in
  stubs__cdist_backward (CArray.start out__) grad x1 x2 p cdist;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _cholesky_solve_helper self ~a ~upper =
  let out__ = CArray.make t 1 in
  stubs__cholesky_solve_helper (CArray.start out__) self a (if upper then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _coalesce self =
  let out__ = CArray.make t 1 in
  stubs__coalesce (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _coalesced_ self ~coalesced =
  let out__ = CArray.make t 1 in
  stubs__coalesced_ (CArray.start out__) self (if coalesced then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _compute_linear_combination input ~coefficients =
  let out__ = CArray.make t 1 in
  stubs__compute_linear_combination (CArray.start out__) input coefficients;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _compute_linear_combination_out ~out input ~coefficients =
  let out__ = CArray.make t 1 in
  stubs__compute_linear_combination_out (CArray.start out__) out input coefficients;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _conj self =
  let out__ = CArray.make t 1 in
  stubs__conj (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _convolution
    input
    ~weight
    ~bias
    ~stride
    ~padding
    ~dilation
    ~transposed
    ~output_padding
    ~groups
    ~benchmark
    ~deterministic
    ~cudnn_enabled
  =
  let out__ = CArray.make t 1 in
  stubs__convolution
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if transposed then 1 else 0)
    (List.map Int64.of_int output_padding |> CArray.of_list int64_t |> CArray.start)
    (List.length output_padding)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0)
    (if cudnn_enabled then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _convolution1
    input
    ~weight
    ~bias
    ~stride
    ~padding
    ~dilation
    ~transposed
    ~output_padding
    ~groups
    ~benchmark
    ~deterministic
    ~cudnn_enabled
    ~allow_tf32
  =
  let out__ = CArray.make t 1 in
  stubs__convolution1
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if transposed then 1 else 0)
    (List.map Int64.of_int output_padding |> CArray.of_list int64_t |> CArray.start)
    (List.length output_padding)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0)
    (if cudnn_enabled then 1 else 0)
    (if allow_tf32 then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _convolution_mode input ~weight ~bias ~stride ~padding ~dilation ~groups =
  let out__ = CArray.make t 1 in
  stubs__convolution_mode
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    padding
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _convolution_nogroup
    input
    ~weight
    ~bias
    ~stride
    ~padding
    ~dilation
    ~transposed
    ~output_padding
  =
  let out__ = CArray.make t 1 in
  stubs__convolution_nogroup
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if transposed then 1 else 0)
    (List.map Int64.of_int output_padding |> CArray.of_list int64_t |> CArray.start)
    (List.length output_padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _copy_from self ~dst ~non_blocking =
  let out__ = CArray.make t 1 in
  stubs__copy_from (CArray.start out__) self dst (if non_blocking then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _ctc_loss ~log_probs ~targets ~input_lengths ~target_lengths ~blank ~zero_infinity =
  let out__ = CArray.make t 2 in
  stubs__ctc_loss
    (CArray.start out__)
    log_probs
    targets
    (List.map Int64.of_int input_lengths |> CArray.of_list int64_t |> CArray.start)
    (List.length input_lengths)
    (List.map Int64.of_int target_lengths |> CArray.of_list int64_t |> CArray.start)
    (List.length target_lengths)
    (Int64.of_int blank)
    (if zero_infinity then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let _ctc_loss_backward
    ~grad
    ~log_probs
    ~targets
    ~input_lengths
    ~target_lengths
    ~neg_log_likelihood
    ~log_alpha
    ~blank
    ~zero_infinity
  =
  let out__ = CArray.make t 1 in
  stubs__ctc_loss_backward
    (CArray.start out__)
    grad
    log_probs
    targets
    (List.map Int64.of_int input_lengths |> CArray.of_list int64_t |> CArray.start)
    (List.length input_lengths)
    (List.map Int64.of_int target_lengths |> CArray.of_list int64_t |> CArray.start)
    (List.length target_lengths)
    neg_log_likelihood
    log_alpha
    (Int64.of_int blank)
    (if zero_infinity then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _cudnn_ctc_loss
    ~log_probs
    ~targets
    ~input_lengths
    ~target_lengths
    ~blank
    ~deterministic
    ~zero_infinity
  =
  let out__ = CArray.make t 2 in
  stubs__cudnn_ctc_loss
    (CArray.start out__)
    log_probs
    targets
    (List.map Int64.of_int input_lengths |> CArray.of_list int64_t |> CArray.start)
    (List.length input_lengths)
    (List.map Int64.of_int target_lengths |> CArray.of_list int64_t |> CArray.start)
    (List.length target_lengths)
    (Int64.of_int blank)
    (if deterministic then 1 else 0)
    (if zero_infinity then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let _cudnn_init_dropout_state ~dropout ~train ~dropout_seed ~options =
  let out__ = CArray.make t 1 in
  stubs__cudnn_init_dropout_state
    (CArray.start out__)
    dropout
    (if train then 1 else 0)
    (Int64.of_int dropout_seed)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _cudnn_rnn
    input
    ~weight
    ~weight_stride0
    ~weight_buf
    ~hx
    ~cx
    ~mode
    ~hidden_size
    ~proj_size
    ~num_layers
    ~batch_first
    ~dropout
    ~train
    ~bidirectional
    ~batch_sizes
    ~dropout_state
  =
  let out__ = CArray.make t 5 in
  stubs__cudnn_rnn
    (CArray.start out__)
    input
    (CArray.of_list t weight |> CArray.start)
    (List.length weight)
    (Int64.of_int weight_stride0)
    (match weight_buf with
    | Some v -> v
    | None -> null)
    hx
    (match cx with
    | Some v -> v
    | None -> null)
    (Int64.of_int mode)
    (Int64.of_int hidden_size)
    (Int64.of_int proj_size)
    (Int64.of_int num_layers)
    (if batch_first then 1 else 0)
    dropout
    (if train then 1 else 0)
    (if bidirectional then 1 else 0)
    (List.map Int64.of_int batch_sizes |> CArray.of_list int64_t |> CArray.start)
    (List.length batch_sizes)
    (match dropout_state with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  let t3 = CArray.get out__ 3 in
  Gc.finalise C.Tensor.free t3;
  let t4 = CArray.get out__ 4 in
  Gc.finalise C.Tensor.free t4;
  t0, t1, t2, t3, t4

let _cudnn_rnn_flatten_weight
    ~weight_arr
    ~weight_stride0
    ~input_size
    ~mode
    ~hidden_size
    ~proj_size
    ~num_layers
    ~batch_first
    ~bidirectional
  =
  let out__ = CArray.make t 1 in
  stubs__cudnn_rnn_flatten_weight
    (CArray.start out__)
    (CArray.of_list t weight_arr |> CArray.start)
    (List.length weight_arr)
    (Int64.of_int weight_stride0)
    (Int64.of_int input_size)
    (Int64.of_int mode)
    (Int64.of_int hidden_size)
    (Int64.of_int proj_size)
    (Int64.of_int num_layers)
    (if batch_first then 1 else 0)
    (if bidirectional then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _cumprod self ~dim =
  let out__ = CArray.make t 1 in
  stubs__cumprod (CArray.start out__) self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _cumprod_out ~out self ~dim =
  let out__ = CArray.make t 1 in
  stubs__cumprod_out (CArray.start out__) out self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _cumsum self ~dim =
  let out__ = CArray.make t 1 in
  stubs__cumsum (CArray.start out__) self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _cumsum_out ~out self ~dim =
  let out__ = CArray.make t 1 in
  stubs__cumsum_out (CArray.start out__) out self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _dim_arange ~like ~dim =
  let out__ = CArray.make t 1 in
  stubs__dim_arange (CArray.start out__) like (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _dirichlet_grad ~x ~alpha ~total =
  let out__ = CArray.make t 1 in
  stubs__dirichlet_grad (CArray.start out__) x alpha total;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _embedding_bag
    ~weight
    ~indices
    ~offsets
    ~scale_grad_by_freq
    ~mode
    ~sparse
    ~per_sample_weights
    ~include_last_offset
    ~padding_idx
  =
  let out__ = CArray.make t 4 in
  stubs__embedding_bag
    (CArray.start out__)
    weight
    indices
    offsets
    (if scale_grad_by_freq then 1 else 0)
    (Int64.of_int mode)
    (if sparse then 1 else 0)
    (match per_sample_weights with
    | Some v -> v
    | None -> null)
    (if include_last_offset then 1 else 0)
    (Int64.of_int padding_idx);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  let t3 = CArray.get out__ 3 in
  Gc.finalise C.Tensor.free t3;
  t0, t1, t2, t3

let _embedding_bag_backward
    ~grad
    ~indices
    ~offsets
    ~offset2bag
    ~bag_size
    ~maximum_indices
    ~num_weights
    ~scale_grad_by_freq
    ~mode
    ~sparse
    ~per_sample_weights
    ~padding_idx
  =
  let out__ = CArray.make t 1 in
  stubs__embedding_bag_backward
    (CArray.start out__)
    grad
    indices
    offsets
    offset2bag
    bag_size
    maximum_indices
    (Int64.of_int num_weights)
    (if scale_grad_by_freq then 1 else 0)
    (Int64.of_int mode)
    (if sparse then 1 else 0)
    (match per_sample_weights with
    | Some v -> v
    | None -> null)
    (Int64.of_int padding_idx);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _embedding_bag_dense_backward
    ~grad
    ~indices
    ~offset2bag
    ~bag_size
    ~maximum_indices
    ~num_weights
    ~scale_grad_by_freq
    ~mode
    ~per_sample_weights
    ~padding_idx
  =
  let out__ = CArray.make t 1 in
  stubs__embedding_bag_dense_backward
    (CArray.start out__)
    grad
    indices
    offset2bag
    bag_size
    maximum_indices
    (Int64.of_int num_weights)
    (if scale_grad_by_freq then 1 else 0)
    (Int64.of_int mode)
    (match per_sample_weights with
    | Some v -> v
    | None -> null)
    (Int64.of_int padding_idx);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _embedding_bag_forward_only
    ~weight
    ~indices
    ~offsets
    ~scale_grad_by_freq
    ~mode
    ~sparse
    ~per_sample_weights
    ~include_last_offset
    ~padding_idx
  =
  let out__ = CArray.make t 4 in
  stubs__embedding_bag_forward_only
    (CArray.start out__)
    weight
    indices
    offsets
    (if scale_grad_by_freq then 1 else 0)
    (Int64.of_int mode)
    (if sparse then 1 else 0)
    (match per_sample_weights with
    | Some v -> v
    | None -> null)
    (if include_last_offset then 1 else 0)
    (Int64.of_int padding_idx);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  let t3 = CArray.get out__ 3 in
  Gc.finalise C.Tensor.free t3;
  t0, t1, t2, t3

let _embedding_bag_per_sample_weights_backward
    ~grad
    ~weight
    ~indices
    ~offsets
    ~offset2bag
    ~mode
    ~padding_idx
  =
  let out__ = CArray.make t 1 in
  stubs__embedding_bag_per_sample_weights_backward
    (CArray.start out__)
    grad
    weight
    indices
    offsets
    offset2bag
    (Int64.of_int mode)
    (Int64.of_int padding_idx);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _embedding_bag_sparse_backward
    ~grad
    ~indices
    ~offsets
    ~offset2bag
    ~bag_size
    ~num_weights
    ~scale_grad_by_freq
    ~mode
    ~per_sample_weights
    ~padding_idx
  =
  let out__ = CArray.make t 1 in
  stubs__embedding_bag_sparse_backward
    (CArray.start out__)
    grad
    indices
    offsets
    offset2bag
    bag_size
    (Int64.of_int num_weights)
    (if scale_grad_by_freq then 1 else 0)
    (Int64.of_int mode)
    (match per_sample_weights with
    | Some v -> v
    | None -> null)
    (Int64.of_int padding_idx);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _empty_affine_quantized ~size ~options ~scale ~zero_point =
  let out__ = CArray.make t 1 in
  stubs__empty_affine_quantized
    (CArray.start out__)
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options))
    scale
    (Int64.of_int zero_point);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _empty_per_channel_affine_quantized ~size ~scales ~zero_points ~axis ~options =
  let out__ = CArray.make t 1 in
  stubs__empty_per_channel_affine_quantized
    (CArray.start out__)
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    scales
    zero_points
    (Int64.of_int axis)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _euclidean_dist ~x1 ~x2 =
  let out__ = CArray.make t 1 in
  stubs__euclidean_dist (CArray.start out__) x1 x2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _fake_quantize_learnable_per_channel_affine
    self
    ~scale
    ~zero_point
    ~axis
    ~quant_min
    ~quant_max
    ~grad_factor
  =
  let out__ = CArray.make t 1 in
  stubs__fake_quantize_learnable_per_channel_affine
    (CArray.start out__)
    self
    scale
    zero_point
    (Int64.of_int axis)
    (Int64.of_int quant_min)
    (Int64.of_int quant_max)
    grad_factor;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _fake_quantize_learnable_per_channel_affine_backward
    ~grad
    self
    ~scale
    ~zero_point
    ~axis
    ~quant_min
    ~quant_max
    ~grad_factor
  =
  let out__ = CArray.make t 3 in
  stubs__fake_quantize_learnable_per_channel_affine_backward
    (CArray.start out__)
    grad
    self
    scale
    zero_point
    (Int64.of_int axis)
    (Int64.of_int quant_min)
    (Int64.of_int quant_max)
    grad_factor;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let _fake_quantize_learnable_per_tensor_affine
    self
    ~scale
    ~zero_point
    ~quant_min
    ~quant_max
    ~grad_factor
  =
  let out__ = CArray.make t 1 in
  stubs__fake_quantize_learnable_per_tensor_affine
    (CArray.start out__)
    self
    scale
    zero_point
    (Int64.of_int quant_min)
    (Int64.of_int quant_max)
    grad_factor;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _fake_quantize_learnable_per_tensor_affine_backward
    ~grad
    self
    ~scale
    ~zero_point
    ~quant_min
    ~quant_max
    ~grad_factor
  =
  let out__ = CArray.make t 3 in
  stubs__fake_quantize_learnable_per_tensor_affine_backward
    (CArray.start out__)
    grad
    self
    scale
    zero_point
    (Int64.of_int quant_min)
    (Int64.of_int quant_max)
    grad_factor;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let _fft_c2c self ~dim ~normalization ~forward =
  let out__ = CArray.make t 1 in
  stubs__fft_c2c
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (Int64.of_int normalization)
    (if forward then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _fft_c2c_out ~out self ~dim ~normalization ~forward =
  let out__ = CArray.make t 1 in
  stubs__fft_c2c_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (Int64.of_int normalization)
    (if forward then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _fft_c2r self ~dim ~normalization ~last_dim_size =
  let out__ = CArray.make t 1 in
  stubs__fft_c2r
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (Int64.of_int normalization)
    (Int64.of_int last_dim_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _fft_c2r_out ~out self ~dim ~normalization ~last_dim_size =
  let out__ = CArray.make t 1 in
  stubs__fft_c2r_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (Int64.of_int normalization)
    (Int64.of_int last_dim_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _fft_r2c self ~dim ~normalization ~onesided =
  let out__ = CArray.make t 1 in
  stubs__fft_r2c
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (Int64.of_int normalization)
    (if onesided then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _fft_r2c_out ~out self ~dim ~normalization ~onesided =
  let out__ = CArray.make t 1 in
  stubs__fft_r2c_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (Int64.of_int normalization)
    (if onesided then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _fused_dropout self ~p =
  let out__ = CArray.make t 2 in
  stubs__fused_dropout (CArray.start out__) self p;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let _fw_primal self ~level =
  let out__ = CArray.make t 1 in
  stubs__fw_primal (CArray.start out__) self (Int64.of_int level);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _gather_sparse_backward self ~dim ~index ~grad =
  let out__ = CArray.make t 1 in
  stubs__gather_sparse_backward (CArray.start out__) self (Int64.of_int dim) index grad;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _grid_sampler_2d_cpu_fallback
    input
    ~grid
    ~interpolation_mode
    ~padding_mode
    ~align_corners
  =
  let out__ = CArray.make t 1 in
  stubs__grid_sampler_2d_cpu_fallback
    (CArray.start out__)
    input
    grid
    (Int64.of_int interpolation_mode)
    (Int64.of_int padding_mode)
    (if align_corners then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _grid_sampler_2d_cpu_fallback_backward
    ~grad_output
    input
    ~grid
    ~interpolation_mode
    ~padding_mode
    ~align_corners
  =
  let out__ = CArray.make t 2 in
  stubs__grid_sampler_2d_cpu_fallback_backward
    (CArray.start out__)
    grad_output
    input
    grid
    (Int64.of_int interpolation_mode)
    (Int64.of_int padding_mode)
    (if align_corners then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let _index_copy_ self ~dim ~index ~source =
  let out__ = CArray.make t 1 in
  stubs__index_copy_ (CArray.start out__) self (Int64.of_int dim) index source;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _index_put_impl_ self ~indices ~values ~accumulate ~unsafe =
  let out__ = CArray.make t 1 in
  stubs__index_put_impl_
    (CArray.start out__)
    self
    (List.map
       (function
         | Some x -> x
         | None -> null)
       indices
    |> CArray.of_list t
    |> CArray.start)
    (List.length indices)
    values
    (if accumulate then 1 else 0)
    (if unsafe then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _indices self =
  let out__ = CArray.make t 1 in
  stubs__indices (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _inverse_helper self =
  let out__ = CArray.make t 1 in
  stubs__inverse_helper (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _linalg_inv_out_helper_ self ~infos_lu ~infos_getri =
  let out__ = CArray.make t 1 in
  stubs__linalg_inv_out_helper_ (CArray.start out__) self infos_lu infos_getri;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _linalg_qr_helper self ~mode =
  let out__ = CArray.make t 2 in
  stubs__linalg_qr_helper (CArray.start out__) self mode;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let _linalg_solve_out_helper_ self other ~infos =
  let out__ = CArray.make t 1 in
  stubs__linalg_solve_out_helper_ (CArray.start out__) self other infos;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _log_softmax self ~dim ~half_to_float =
  let out__ = CArray.make t 1 in
  stubs__log_softmax
    (CArray.start out__)
    self
    (Int64.of_int dim)
    (if half_to_float then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _log_softmax_backward_data ~grad_output ~output ~dim self =
  let out__ = CArray.make t 1 in
  stubs__log_softmax_backward_data
    (CArray.start out__)
    grad_output
    output
    (Int64.of_int dim)
    self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _logcumsumexp self ~dim =
  let out__ = CArray.make t 1 in
  stubs__logcumsumexp (CArray.start out__) self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _logcumsumexp_out ~out self ~dim =
  let out__ = CArray.make t 1 in
  stubs__logcumsumexp_out (CArray.start out__) out self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _lu_with_info self ~pivot ~check_errors =
  let out__ = CArray.make t 3 in
  stubs__lu_with_info
    (CArray.start out__)
    self
    (if pivot then 1 else 0)
    (if check_errors then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let _make_dual ~primal ~tangent ~level =
  let out__ = CArray.make t 1 in
  stubs__make_dual (CArray.start out__) primal tangent (Int64.of_int level);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _make_per_channel_quantized_tensor self ~scale ~zero_point ~axis =
  let out__ = CArray.make t 1 in
  stubs__make_per_channel_quantized_tensor
    (CArray.start out__)
    self
    scale
    zero_point
    (Int64.of_int axis);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _make_per_tensor_quantized_tensor self ~scale ~zero_point =
  let out__ = CArray.make t 1 in
  stubs__make_per_tensor_quantized_tensor
    (CArray.start out__)
    self
    scale
    (Int64.of_int zero_point);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _masked_scale self ~mask ~scale =
  let out__ = CArray.make t 1 in
  stubs__masked_scale (CArray.start out__) self mask scale;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _mkldnn_reshape self ~shape =
  let out__ = CArray.make t 1 in
  stubs__mkldnn_reshape
    (CArray.start out__)
    self
    (List.map Int64.of_int shape |> CArray.of_list int64_t |> CArray.start)
    (List.length shape);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _mkldnn_transpose self ~dim0 ~dim1 =
  let out__ = CArray.make t 1 in
  stubs__mkldnn_transpose
    (CArray.start out__)
    self
    (Int64.of_int dim0)
    (Int64.of_int dim1);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _mkldnn_transpose_ self ~dim0 ~dim1 =
  let out__ = CArray.make t 1 in
  stubs__mkldnn_transpose_
    (CArray.start out__)
    self
    (Int64.of_int dim0)
    (Int64.of_int dim1);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _nnpack_spatial_convolution input ~weight ~bias ~padding ~stride =
  let out__ = CArray.make t 1 in
  stubs__nnpack_spatial_convolution
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _nnpack_spatial_convolution_backward_input input ~grad_output ~weight ~padding =
  let out__ = CArray.make t 1 in
  stubs__nnpack_spatial_convolution_backward_input
    (CArray.start out__)
    input
    grad_output
    weight
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _nnpack_spatial_convolution_backward_weight input ~weightsize ~grad_output ~padding =
  let out__ = CArray.make t 1 in
  stubs__nnpack_spatial_convolution_backward_weight
    (CArray.start out__)
    input
    (List.map Int64.of_int weightsize |> CArray.of_list int64_t |> CArray.start)
    (List.length weightsize)
    grad_output
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _pack_padded_sequence input ~lengths ~batch_first =
  let out__ = CArray.make t 2 in
  stubs__pack_padded_sequence
    (CArray.start out__)
    input
    lengths
    (if batch_first then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let _pack_padded_sequence_backward ~grad ~input_size ~batch_sizes ~batch_first =
  let out__ = CArray.make t 1 in
  stubs__pack_padded_sequence_backward
    (CArray.start out__)
    grad
    (List.map Int64.of_int input_size |> CArray.of_list int64_t |> CArray.start)
    (List.length input_size)
    batch_sizes
    (if batch_first then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _pdist_backward ~grad self ~p ~pdist =
  let out__ = CArray.make t 1 in
  stubs__pdist_backward (CArray.start out__) grad self p pdist;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _remove_batch_dim self ~level ~batch_size ~out_dim =
  let out__ = CArray.make t 1 in
  stubs__remove_batch_dim
    (CArray.start out__)
    self
    (Int64.of_int level)
    (Int64.of_int batch_size)
    (Int64.of_int out_dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _reshape_from_tensor self ~shape =
  let out__ = CArray.make t 1 in
  stubs__reshape_from_tensor (CArray.start out__) self shape;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _rowwise_prune ~weight ~mask ~compressed_indices_dtype =
  let out__ = CArray.make t 2 in
  stubs__rowwise_prune
    (CArray.start out__)
    weight
    mask
    (Kind.packed_to_int compressed_indices_dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let _s_where ~condition self other =
  let out__ = CArray.make t 1 in
  stubs__s_where (CArray.start out__) condition self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sample_dirichlet self =
  let out__ = CArray.make t 1 in
  stubs__sample_dirichlet (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _saturate_weight_to_fp16 ~weight =
  let out__ = CArray.make t 1 in
  stubs__saturate_weight_to_fp16 (CArray.start out__) weight;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _shape_as_tensor self =
  let out__ = CArray.make t 1 in
  stubs__shape_as_tensor (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sobol_engine_draw ~quasi ~n ~sobolstate ~dimension ~num_generated ~dtype =
  let out__ = CArray.make t 2 in
  stubs__sobol_engine_draw
    (CArray.start out__)
    quasi
    (Int64.of_int n)
    sobolstate
    (Int64.of_int dimension)
    (Int64.of_int num_generated)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let _sobol_engine_ff_ self ~n ~sobolstate ~dimension ~num_generated =
  let out__ = CArray.make t 1 in
  stubs__sobol_engine_ff_
    (CArray.start out__)
    self
    (Int64.of_int n)
    sobolstate
    (Int64.of_int dimension)
    (Int64.of_int num_generated);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sobol_engine_initialize_state_ self ~dimension =
  let out__ = CArray.make t 1 in
  stubs__sobol_engine_initialize_state_ (CArray.start out__) self (Int64.of_int dimension);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sobol_engine_scramble_ self ~ltm ~dimension =
  let out__ = CArray.make t 1 in
  stubs__sobol_engine_scramble_ (CArray.start out__) self ltm (Int64.of_int dimension);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _softmax self ~dim ~half_to_float =
  let out__ = CArray.make t 1 in
  stubs__softmax
    (CArray.start out__)
    self
    (Int64.of_int dim)
    (if half_to_float then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _softmax_backward_data ~grad_output ~output ~dim self =
  let out__ = CArray.make t 1 in
  stubs__softmax_backward_data
    (CArray.start out__)
    grad_output
    output
    (Int64.of_int dim)
    self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _solve_helper self ~a =
  let out__ = CArray.make t 2 in
  stubs__solve_helper (CArray.start out__) self a;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let _sparse_addmm self ~sparse ~dense =
  let out__ = CArray.make t 1 in
  stubs__sparse_addmm (CArray.start out__) self sparse dense;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_coo_tensor_unsafe ~indices ~values ~size ~options =
  let out__ = CArray.make t 1 in
  stubs__sparse_coo_tensor_unsafe
    (CArray.start out__)
    indices
    values
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_coo_tensor_with_dims ~sparse_dim ~dense_dim ~size ~options =
  let out__ = CArray.make t 1 in
  stubs__sparse_coo_tensor_with_dims
    (CArray.start out__)
    (Int64.of_int sparse_dim)
    (Int64.of_int dense_dim)
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_coo_tensor_with_dims_and_tensors
    ~sparse_dim
    ~dense_dim
    ~size
    ~indices
    ~values
    ~options
  =
  let out__ = CArray.make t 1 in
  stubs__sparse_coo_tensor_with_dims_and_tensors
    (CArray.start out__)
    (Int64.of_int sparse_dim)
    (Int64.of_int dense_dim)
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    indices
    values
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_csr_tensor ~crow_indices ~col_indices ~values ~options =
  let out__ = CArray.make t 1 in
  stubs__sparse_csr_tensor
    (CArray.start out__)
    crow_indices
    col_indices
    values
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_csr_tensor1 ~crow_indices ~col_indices ~values ~size ~options =
  let out__ = CArray.make t 1 in
  stubs__sparse_csr_tensor1
    (CArray.start out__)
    crow_indices
    col_indices
    values
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_log_softmax self ~dim ~dtype =
  let out__ = CArray.make t 1 in
  stubs__sparse_log_softmax
    (CArray.start out__)
    self
    (Int64.of_int dim)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_log_softmax1 self ~dim ~half_to_float =
  let out__ = CArray.make t 1 in
  stubs__sparse_log_softmax1
    (CArray.start out__)
    self
    (Int64.of_int dim)
    (if half_to_float then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_log_softmax_backward_data ~grad_output ~output ~dim self =
  let out__ = CArray.make t 1 in
  stubs__sparse_log_softmax_backward_data
    (CArray.start out__)
    grad_output
    output
    (Int64.of_int dim)
    self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_mask_helper ~tr ~mask_indices =
  let out__ = CArray.make t 1 in
  stubs__sparse_mask_helper (CArray.start out__) tr mask_indices;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_mm ~sparse ~dense =
  let out__ = CArray.make t 1 in
  stubs__sparse_mm (CArray.start out__) sparse dense;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_softmax self ~dim ~dtype =
  let out__ = CArray.make t 1 in
  stubs__sparse_softmax
    (CArray.start out__)
    self
    (Int64.of_int dim)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_softmax1 self ~dim ~half_to_float =
  let out__ = CArray.make t 1 in
  stubs__sparse_softmax1
    (CArray.start out__)
    self
    (Int64.of_int dim)
    (if half_to_float then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_softmax_backward_data ~grad_output ~output ~dim self =
  let out__ = CArray.make t 1 in
  stubs__sparse_softmax_backward_data
    (CArray.start out__)
    grad_output
    output
    (Int64.of_int dim)
    self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_sparse_matmul self other =
  let out__ = CArray.make t 1 in
  stubs__sparse_sparse_matmul (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_sum self =
  let out__ = CArray.make t 1 in
  stubs__sparse_sum (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_sum1 self ~dtype =
  let out__ = CArray.make t 1 in
  stubs__sparse_sum1 (CArray.start out__) self (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_sum2 self ~dim =
  let out__ = CArray.make t 1 in
  stubs__sparse_sum2
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_sum3 self ~dim ~dtype =
  let out__ = CArray.make t 1 in
  stubs__sparse_sum3
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _sparse_sum_backward ~grad self ~dim =
  let out__ = CArray.make t 1 in
  stubs__sparse_sum_backward
    (CArray.start out__)
    grad
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _stack tensors ~dim =
  let out__ = CArray.make t 1 in
  stubs__stack
    (CArray.start out__)
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors)
    (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _stack_out ~out tensors ~dim =
  let out__ = CArray.make t 1 in
  stubs__stack_out
    (CArray.start out__)
    out
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors)
    (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _standard_gamma self =
  let out__ = CArray.make t 1 in
  stubs__standard_gamma (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _standard_gamma_grad self ~output =
  let out__ = CArray.make t 1 in
  stubs__standard_gamma_grad (CArray.start out__) self output;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _svd_helper self ~some ~compute_uv =
  let out__ = CArray.make t 3 in
  stubs__svd_helper
    (CArray.start out__)
    self
    (if some then 1 else 0)
    (if compute_uv then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let _symeig_helper self ~eigenvectors ~upper =
  let out__ = CArray.make t 2 in
  stubs__symeig_helper
    (CArray.start out__)
    self
    (if eigenvectors then 1 else 0)
    (if upper then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let _test_ambiguous_defaults ~dummy ~a ~b =
  let out__ = CArray.make t 1 in
  stubs__test_ambiguous_defaults
    (CArray.start out__)
    dummy
    (Int64.of_int a)
    (Int64.of_int b);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _test_ambiguous_defaults1 ~dummy ~a ~b =
  let out__ = CArray.make t 1 in
  stubs__test_ambiguous_defaults1 (CArray.start out__) dummy (Int64.of_int a) b;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _test_optional_filled_intlist ~values ~addends =
  let out__ = CArray.make t 1 in
  stubs__test_optional_filled_intlist
    (CArray.start out__)
    values
    (List.map Int64.of_int addends |> CArray.of_list int64_t |> CArray.start)
    (List.length addends);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _test_optional_intlist ~values ~addends =
  let out__ = CArray.make t 1 in
  stubs__test_optional_intlist
    (CArray.start out__)
    values
    (List.map Int64.of_int addends |> CArray.of_list int64_t |> CArray.start)
    (List.length addends);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _test_serialization_subcmul self other =
  let out__ = CArray.make t 1 in
  stubs__test_serialization_subcmul (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _test_string_default ~dummy ~a ~b =
  let out__ = CArray.make t 1 in
  stubs__test_string_default (CArray.start out__) dummy a b;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _thnn_differentiable_gru_cell_backward
    ~grad_hy
    ~input_gates
    ~hidden_gates
    ~hx
    ~input_bias
    ~hidden_bias
  =
  let out__ = CArray.make t 5 in
  stubs__thnn_differentiable_gru_cell_backward
    (CArray.start out__)
    grad_hy
    input_gates
    hidden_gates
    hx
    (match input_bias with
    | Some v -> v
    | None -> null)
    (match hidden_bias with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  let t3 = CArray.get out__ 3 in
  Gc.finalise C.Tensor.free t3;
  let t4 = CArray.get out__ 4 in
  Gc.finalise C.Tensor.free t4;
  t0, t1, t2, t3, t4

let _thnn_differentiable_lstm_cell_backward
    ~grad_hy
    ~grad_cy
    ~input_gates
    ~hidden_gates
    ~input_bias
    ~hidden_bias
    ~cx
    ~cy
  =
  let out__ = CArray.make t 5 in
  stubs__thnn_differentiable_lstm_cell_backward
    (CArray.start out__)
    (match grad_hy with
    | Some v -> v
    | None -> null)
    (match grad_cy with
    | Some v -> v
    | None -> null)
    input_gates
    hidden_gates
    (match input_bias with
    | Some v -> v
    | None -> null)
    (match hidden_bias with
    | Some v -> v
    | None -> null)
    cx
    cy;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  let t3 = CArray.get out__ 3 in
  Gc.finalise C.Tensor.free t3;
  let t4 = CArray.get out__ 4 in
  Gc.finalise C.Tensor.free t4;
  t0, t1, t2, t3, t4

let _thnn_fused_gru_cell ~input_gates ~hidden_gates ~hx ~input_bias ~hidden_bias =
  let out__ = CArray.make t 2 in
  stubs__thnn_fused_gru_cell
    (CArray.start out__)
    input_gates
    hidden_gates
    hx
    (match input_bias with
    | Some v -> v
    | None -> null)
    (match hidden_bias with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let _thnn_fused_gru_cell_backward ~grad_hy ~workspace ~has_bias =
  let out__ = CArray.make t 5 in
  stubs__thnn_fused_gru_cell_backward
    (CArray.start out__)
    grad_hy
    workspace
    (if has_bias then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  let t3 = CArray.get out__ 3 in
  Gc.finalise C.Tensor.free t3;
  let t4 = CArray.get out__ 4 in
  Gc.finalise C.Tensor.free t4;
  t0, t1, t2, t3, t4

let _thnn_fused_lstm_cell ~input_gates ~hidden_gates ~cx ~input_bias ~hidden_bias =
  let out__ = CArray.make t 3 in
  stubs__thnn_fused_lstm_cell
    (CArray.start out__)
    input_gates
    hidden_gates
    cx
    (match input_bias with
    | Some v -> v
    | None -> null)
    (match hidden_bias with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let _thnn_fused_lstm_cell_backward ~grad_hy ~grad_cy ~cx ~cy ~workspace ~has_bias =
  let out__ = CArray.make t 5 in
  stubs__thnn_fused_lstm_cell_backward
    (CArray.start out__)
    (match grad_hy with
    | Some v -> v
    | None -> null)
    (match grad_cy with
    | Some v -> v
    | None -> null)
    cx
    cy
    workspace
    (if has_bias then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  let t3 = CArray.get out__ 3 in
  Gc.finalise C.Tensor.free t3;
  let t4 = CArray.get out__ 4 in
  Gc.finalise C.Tensor.free t4;
  t0, t1, t2, t3, t4

let _trilinear ~i1 ~i2 ~i3 ~expand1 ~expand2 ~expand3 ~sumdim ~unroll_dim =
  let out__ = CArray.make t 1 in
  stubs__trilinear
    (CArray.start out__)
    i1
    i2
    i3
    (List.map Int64.of_int expand1 |> CArray.of_list int64_t |> CArray.start)
    (List.length expand1)
    (List.map Int64.of_int expand2 |> CArray.of_list int64_t |> CArray.start)
    (List.length expand2)
    (List.map Int64.of_int expand3 |> CArray.of_list int64_t |> CArray.start)
    (List.length expand3)
    (List.map Int64.of_int sumdim |> CArray.of_list int64_t |> CArray.start)
    (List.length sumdim)
    (Int64.of_int unroll_dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _unique self ~sorted ~return_inverse =
  let out__ = CArray.make t 2 in
  stubs__unique
    (CArray.start out__)
    self
    (if sorted then 1 else 0)
    (if return_inverse then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let _unique2 self ~sorted ~return_inverse ~return_counts =
  let out__ = CArray.make t 3 in
  stubs__unique2
    (CArray.start out__)
    self
    (if sorted then 1 else 0)
    (if return_inverse then 1 else 0)
    (if return_counts then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let _unpack_dual ~dual ~level =
  let out__ = CArray.make t 2 in
  stubs__unpack_dual (CArray.start out__) dual (Int64.of_int level);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let _unsafe_view self ~size =
  let out__ = CArray.make t 1 in
  stubs__unsafe_view
    (CArray.start out__)
    self
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _values self =
  let out__ = CArray.make t 1 in
  stubs__values (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _weight_norm ~v ~g ~dim =
  let out__ = CArray.make t 1 in
  stubs__weight_norm (CArray.start out__) v g (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let _weight_norm_cuda_interface ~v ~g ~dim =
  let out__ = CArray.make t 2 in
  stubs__weight_norm_cuda_interface (CArray.start out__) v g (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let _weight_norm_cuda_interface_backward ~grad_w ~saved_v ~saved_g ~saved_norms ~dim =
  let out__ = CArray.make t 2 in
  stubs__weight_norm_cuda_interface_backward
    (CArray.start out__)
    grad_w
    saved_v
    saved_g
    saved_norms
    (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let _weight_norm_differentiable_backward ~grad_w ~saved_v ~saved_g ~saved_norms ~dim =
  let out__ = CArray.make t 2 in
  stubs__weight_norm_differentiable_backward
    (CArray.start out__)
    grad_w
    saved_v
    saved_g
    saved_norms
    (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let abs self =
  let out__ = CArray.make t 1 in
  stubs_abs (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let abs_ self =
  let out__ = CArray.make t 1 in
  stubs_abs_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let abs_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_abs_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let absolute self =
  let out__ = CArray.make t 1 in
  stubs_absolute (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let absolute_ self =
  let out__ = CArray.make t 1 in
  stubs_absolute_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let absolute_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_absolute_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let acos self =
  let out__ = CArray.make t 1 in
  stubs_acos (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let acos_ self =
  let out__ = CArray.make t 1 in
  stubs_acos_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let acos_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_acos_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let acosh self =
  let out__ = CArray.make t 1 in
  stubs_acosh (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let acosh_ self =
  let out__ = CArray.make t 1 in
  stubs_acosh_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let acosh_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_acosh_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let adaptive_avg_pool1d self ~output_size =
  let out__ = CArray.make t 1 in
  stubs_adaptive_avg_pool1d
    (CArray.start out__)
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let adaptive_avg_pool2d self ~output_size =
  let out__ = CArray.make t 1 in
  stubs_adaptive_avg_pool2d
    (CArray.start out__)
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let adaptive_avg_pool2d_out ~out self ~output_size =
  let out__ = CArray.make t 1 in
  stubs_adaptive_avg_pool2d_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let adaptive_avg_pool3d self ~output_size =
  let out__ = CArray.make t 1 in
  stubs_adaptive_avg_pool3d
    (CArray.start out__)
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let adaptive_avg_pool3d_backward_out ~grad_input ~grad_output self =
  let out__ = CArray.make t 1 in
  stubs_adaptive_avg_pool3d_backward_out (CArray.start out__) grad_input grad_output self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let adaptive_avg_pool3d_out ~out self ~output_size =
  let out__ = CArray.make t 1 in
  stubs_adaptive_avg_pool3d_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let adaptive_max_pool1d self ~output_size =
  let out__ = CArray.make t 2 in
  stubs_adaptive_max_pool1d
    (CArray.start out__)
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let adaptive_max_pool2d self ~output_size =
  let out__ = CArray.make t 2 in
  stubs_adaptive_max_pool2d
    (CArray.start out__)
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let adaptive_max_pool2d_backward ~grad_output self ~indices =
  let out__ = CArray.make t 1 in
  stubs_adaptive_max_pool2d_backward (CArray.start out__) grad_output self indices;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let adaptive_max_pool2d_backward_out ~grad_input ~grad_output self ~indices =
  let out__ = CArray.make t 1 in
  stubs_adaptive_max_pool2d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    indices;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let adaptive_max_pool2d_out ~out ~indices self ~output_size =
  let out__ = CArray.make t 2 in
  stubs_adaptive_max_pool2d_out
    (CArray.start out__)
    out
    indices
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let adaptive_max_pool3d self ~output_size =
  let out__ = CArray.make t 2 in
  stubs_adaptive_max_pool3d
    (CArray.start out__)
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let adaptive_max_pool3d_backward ~grad_output self ~indices =
  let out__ = CArray.make t 1 in
  stubs_adaptive_max_pool3d_backward (CArray.start out__) grad_output self indices;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let adaptive_max_pool3d_backward_out ~grad_input ~grad_output self ~indices =
  let out__ = CArray.make t 1 in
  stubs_adaptive_max_pool3d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    indices;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let adaptive_max_pool3d_out ~out ~indices self ~output_size =
  let out__ = CArray.make t 2 in
  stubs_adaptive_max_pool3d_out
    (CArray.start out__)
    out
    indices
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let add self other =
  let out__ = CArray.make t 1 in
  stubs_add (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let add_ self other =
  let out__ = CArray.make t 1 in
  stubs_add_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let add_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_add_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let addbmm self ~batch1 ~batch2 =
  let out__ = CArray.make t 1 in
  stubs_addbmm (CArray.start out__) self batch1 batch2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let addbmm_ self ~batch1 ~batch2 =
  let out__ = CArray.make t 1 in
  stubs_addbmm_ (CArray.start out__) self batch1 batch2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let addbmm_out ~out self ~batch1 ~batch2 =
  let out__ = CArray.make t 1 in
  stubs_addbmm_out (CArray.start out__) out self batch1 batch2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let addcdiv self ~tensor1 ~tensor2 =
  let out__ = CArray.make t 1 in
  stubs_addcdiv (CArray.start out__) self tensor1 tensor2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let addcdiv_ self ~tensor1 ~tensor2 =
  let out__ = CArray.make t 1 in
  stubs_addcdiv_ (CArray.start out__) self tensor1 tensor2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let addcdiv_out ~out self ~tensor1 ~tensor2 =
  let out__ = CArray.make t 1 in
  stubs_addcdiv_out (CArray.start out__) out self tensor1 tensor2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let addcmul self ~tensor1 ~tensor2 =
  let out__ = CArray.make t 1 in
  stubs_addcmul (CArray.start out__) self tensor1 tensor2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let addcmul_ self ~tensor1 ~tensor2 =
  let out__ = CArray.make t 1 in
  stubs_addcmul_ (CArray.start out__) self tensor1 tensor2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let addcmul_out ~out self ~tensor1 ~tensor2 =
  let out__ = CArray.make t 1 in
  stubs_addcmul_out (CArray.start out__) out self tensor1 tensor2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let addmm self ~mat1 ~mat2 =
  let out__ = CArray.make t 1 in
  stubs_addmm (CArray.start out__) self mat1 mat2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let addmm_ self ~mat1 ~mat2 =
  let out__ = CArray.make t 1 in
  stubs_addmm_ (CArray.start out__) self mat1 mat2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let addmm_out ~out self ~mat1 ~mat2 =
  let out__ = CArray.make t 1 in
  stubs_addmm_out (CArray.start out__) out self mat1 mat2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let addmv self ~mat ~vec =
  let out__ = CArray.make t 1 in
  stubs_addmv (CArray.start out__) self mat vec;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let addmv_ self ~mat ~vec =
  let out__ = CArray.make t 1 in
  stubs_addmv_ (CArray.start out__) self mat vec;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let addmv_out ~out self ~mat ~vec =
  let out__ = CArray.make t 1 in
  stubs_addmv_out (CArray.start out__) out self mat vec;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let addr self ~vec1 ~vec2 =
  let out__ = CArray.make t 1 in
  stubs_addr (CArray.start out__) self vec1 vec2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let addr_ self ~vec1 ~vec2 =
  let out__ = CArray.make t 1 in
  stubs_addr_ (CArray.start out__) self vec1 vec2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let addr_out ~out self ~vec1 ~vec2 =
  let out__ = CArray.make t 1 in
  stubs_addr_out (CArray.start out__) out self vec1 vec2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let affine_grid_generator ~theta ~size ~align_corners =
  let out__ = CArray.make t 1 in
  stubs_affine_grid_generator
    (CArray.start out__)
    theta
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (if align_corners then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let affine_grid_generator_backward ~grad ~size ~align_corners =
  let out__ = CArray.make t 1 in
  stubs_affine_grid_generator_backward
    (CArray.start out__)
    grad
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (if align_corners then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let alias self =
  let out__ = CArray.make t 1 in
  stubs_alias (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let align_as self other =
  let out__ = CArray.make t 1 in
  stubs_align_as (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let align_tensors tensors =
  stubs_align_tensors (CArray.of_list t tensors |> CArray.start) (List.length tensors)
  |> to_tensor_list

let all self =
  let out__ = CArray.make t 1 in
  stubs_all (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let all1 self ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_all1 (CArray.start out__) self (Int64.of_int dim) (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let all_out ~out self ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_all_out
    (CArray.start out__)
    out
    self
    (Int64.of_int dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let alpha_dropout input ~p ~train =
  let out__ = CArray.make t 1 in
  stubs_alpha_dropout (CArray.start out__) input p (if train then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let alpha_dropout_ self ~p ~train =
  let out__ = CArray.make t 1 in
  stubs_alpha_dropout_ (CArray.start out__) self p (if train then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let amax self ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_amax
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let amax_out ~out self ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_amax_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let amin self ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_amin
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let amin_out ~out self ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_amin_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let angle self =
  let out__ = CArray.make t 1 in
  stubs_angle (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let angle_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_angle_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let any self =
  let out__ = CArray.make t 1 in
  stubs_any (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let any1 self ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_any1 (CArray.start out__) self (Int64.of_int dim) (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let any_out ~out self ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_any_out
    (CArray.start out__)
    out
    self
    (Int64.of_int dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let arccos self =
  let out__ = CArray.make t 1 in
  stubs_arccos (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let arccos_ self =
  let out__ = CArray.make t 1 in
  stubs_arccos_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let arccos_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_arccos_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let arccosh self =
  let out__ = CArray.make t 1 in
  stubs_arccosh (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let arccosh_ self =
  let out__ = CArray.make t 1 in
  stubs_arccosh_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let arccosh_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_arccosh_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let arcsin self =
  let out__ = CArray.make t 1 in
  stubs_arcsin (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let arcsin_ self =
  let out__ = CArray.make t 1 in
  stubs_arcsin_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let arcsin_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_arcsin_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let arcsinh self =
  let out__ = CArray.make t 1 in
  stubs_arcsinh (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let arcsinh_ self =
  let out__ = CArray.make t 1 in
  stubs_arcsinh_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let arcsinh_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_arcsinh_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let arctan self =
  let out__ = CArray.make t 1 in
  stubs_arctan (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let arctan_ self =
  let out__ = CArray.make t 1 in
  stubs_arctan_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let arctan_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_arctan_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let arctanh self =
  let out__ = CArray.make t 1 in
  stubs_arctanh (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let arctanh_ self =
  let out__ = CArray.make t 1 in
  stubs_arctanh_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let arctanh_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_arctanh_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let argmax self ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_argmax (CArray.start out__) self (Int64.of_int dim) (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let argmax_out ~out self ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_argmax_out
    (CArray.start out__)
    out
    self
    (Int64.of_int dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let argmin self ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_argmin (CArray.start out__) self (Int64.of_int dim) (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let argmin_out ~out self ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_argmin_out
    (CArray.start out__)
    out
    self
    (Int64.of_int dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let argsort self ~dim ~descending =
  let out__ = CArray.make t 1 in
  stubs_argsort (CArray.start out__) self (Int64.of_int dim) (if descending then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let as_strided self ~size ~stride ~storage_offset =
  let out__ = CArray.make t 1 in
  stubs_as_strided
    (CArray.start out__)
    self
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (Int64.of_int storage_offset);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let as_strided_ self ~size ~stride ~storage_offset =
  let out__ = CArray.make t 1 in
  stubs_as_strided_
    (CArray.start out__)
    self
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (Int64.of_int storage_offset);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let asin self =
  let out__ = CArray.make t 1 in
  stubs_asin (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let asin_ self =
  let out__ = CArray.make t 1 in
  stubs_asin_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let asin_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_asin_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let asinh self =
  let out__ = CArray.make t 1 in
  stubs_asinh (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let asinh_ self =
  let out__ = CArray.make t 1 in
  stubs_asinh_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let asinh_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_asinh_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let atan self =
  let out__ = CArray.make t 1 in
  stubs_atan (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let atan2 self other =
  let out__ = CArray.make t 1 in
  stubs_atan2 (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let atan2_ self other =
  let out__ = CArray.make t 1 in
  stubs_atan2_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let atan2_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_atan2_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let atan_ self =
  let out__ = CArray.make t 1 in
  stubs_atan_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let atan_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_atan_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let atanh self =
  let out__ = CArray.make t 1 in
  stubs_atanh (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let atanh_ self =
  let out__ = CArray.make t 1 in
  stubs_atanh_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let atanh_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_atanh_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let atleast_1d self =
  let out__ = CArray.make t 1 in
  stubs_atleast_1d (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let atleast_1d1 tensors =
  stubs_atleast_1d1 (CArray.of_list t tensors |> CArray.start) (List.length tensors)
  |> to_tensor_list

let atleast_2d self =
  let out__ = CArray.make t 1 in
  stubs_atleast_2d (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let atleast_2d1 tensors =
  stubs_atleast_2d1 (CArray.of_list t tensors |> CArray.start) (List.length tensors)
  |> to_tensor_list

let atleast_3d self =
  let out__ = CArray.make t 1 in
  stubs_atleast_3d (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let atleast_3d1 tensors =
  stubs_atleast_3d1 (CArray.of_list t tensors |> CArray.start) (List.length tensors)
  |> to_tensor_list

let avg_pool1d self ~kernel_size ~stride ~padding ~ceil_mode ~count_include_pad =
  let out__ = CArray.make t 1 in
  stubs_avg_pool1d
    (CArray.start out__)
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (if ceil_mode then 1 else 0)
    (if count_include_pad then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let avg_pool2d
    self
    ~kernel_size
    ~stride
    ~padding
    ~ceil_mode
    ~count_include_pad
    ~divisor_override
  =
  let out__ = CArray.make t 1 in
  stubs_avg_pool2d
    (CArray.start out__)
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (if ceil_mode then 1 else 0)
    (if count_include_pad then 1 else 0)
    (Int64.of_int divisor_override);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let avg_pool2d_backward
    ~grad_output
    self
    ~kernel_size
    ~stride
    ~padding
    ~ceil_mode
    ~count_include_pad
    ~divisor_override
  =
  let out__ = CArray.make t 1 in
  stubs_avg_pool2d_backward
    (CArray.start out__)
    grad_output
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (if ceil_mode then 1 else 0)
    (if count_include_pad then 1 else 0)
    (Int64.of_int divisor_override);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let avg_pool2d_backward_out
    ~grad_input
    ~grad_output
    self
    ~kernel_size
    ~stride
    ~padding
    ~ceil_mode
    ~count_include_pad
    ~divisor_override
  =
  let out__ = CArray.make t 1 in
  stubs_avg_pool2d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (if ceil_mode then 1 else 0)
    (if count_include_pad then 1 else 0)
    (Int64.of_int divisor_override);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let avg_pool2d_out
    ~out
    self
    ~kernel_size
    ~stride
    ~padding
    ~ceil_mode
    ~count_include_pad
    ~divisor_override
  =
  let out__ = CArray.make t 1 in
  stubs_avg_pool2d_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (if ceil_mode then 1 else 0)
    (if count_include_pad then 1 else 0)
    (Int64.of_int divisor_override);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let avg_pool3d
    self
    ~kernel_size
    ~stride
    ~padding
    ~ceil_mode
    ~count_include_pad
    ~divisor_override
  =
  let out__ = CArray.make t 1 in
  stubs_avg_pool3d
    (CArray.start out__)
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (if ceil_mode then 1 else 0)
    (if count_include_pad then 1 else 0)
    (Int64.of_int divisor_override);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let avg_pool3d_backward
    ~grad_output
    self
    ~kernel_size
    ~stride
    ~padding
    ~ceil_mode
    ~count_include_pad
    ~divisor_override
  =
  let out__ = CArray.make t 1 in
  stubs_avg_pool3d_backward
    (CArray.start out__)
    grad_output
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (if ceil_mode then 1 else 0)
    (if count_include_pad then 1 else 0)
    (Int64.of_int divisor_override);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let avg_pool3d_backward_out
    ~grad_input
    ~grad_output
    self
    ~kernel_size
    ~stride
    ~padding
    ~ceil_mode
    ~count_include_pad
    ~divisor_override
  =
  let out__ = CArray.make t 1 in
  stubs_avg_pool3d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (if ceil_mode then 1 else 0)
    (if count_include_pad then 1 else 0)
    (Int64.of_int divisor_override);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let avg_pool3d_out
    ~out
    self
    ~kernel_size
    ~stride
    ~padding
    ~ceil_mode
    ~count_include_pad
    ~divisor_override
  =
  let out__ = CArray.make t 1 in
  stubs_avg_pool3d_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (if ceil_mode then 1 else 0)
    (if count_include_pad then 1 else 0)
    (Int64.of_int divisor_override);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let baddbmm self ~batch1 ~batch2 =
  let out__ = CArray.make t 1 in
  stubs_baddbmm (CArray.start out__) self batch1 batch2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let baddbmm_ self ~batch1 ~batch2 =
  let out__ = CArray.make t 1 in
  stubs_baddbmm_ (CArray.start out__) self batch1 batch2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let baddbmm_out ~out self ~batch1 ~batch2 =
  let out__ = CArray.make t 1 in
  stubs_baddbmm_out (CArray.start out__) out self batch1 batch2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bartlett_window ~window_length ~options =
  let out__ = CArray.make t 1 in
  stubs_bartlett_window
    (CArray.start out__)
    (Int64.of_int window_length)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bartlett_window1 ~window_length ~periodic ~options =
  let out__ = CArray.make t 1 in
  stubs_bartlett_window1
    (CArray.start out__)
    (Int64.of_int window_length)
    (if periodic then 1 else 0)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let batch_norm
    input
    ~weight
    ~bias
    ~running_mean
    ~running_var
    ~training
    ~momentum
    ~eps
    ~cudnn_enabled
  =
  let out__ = CArray.make t 1 in
  stubs_batch_norm
    (CArray.start out__)
    input
    (match weight with
    | Some v -> v
    | None -> null)
    (match bias with
    | Some v -> v
    | None -> null)
    (match running_mean with
    | Some v -> v
    | None -> null)
    (match running_var with
    | Some v -> v
    | None -> null)
    (if training then 1 else 0)
    momentum
    eps
    (if cudnn_enabled then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let batch_norm_backward_elemt
    ~grad_out
    input
    ~mean
    ~invstd
    ~weight
    ~mean_dy
    ~mean_dy_xmu
    ~count
  =
  let out__ = CArray.make t 1 in
  stubs_batch_norm_backward_elemt
    (CArray.start out__)
    grad_out
    input
    mean
    invstd
    (match weight with
    | Some v -> v
    | None -> null)
    mean_dy
    mean_dy_xmu
    count;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let batch_norm_backward_reduce
    ~grad_out
    input
    ~mean
    ~invstd
    ~weight
    ~input_g
    ~weight_g
    ~bias_g
  =
  let out__ = CArray.make t 4 in
  stubs_batch_norm_backward_reduce
    (CArray.start out__)
    grad_out
    input
    mean
    invstd
    (match weight with
    | Some v -> v
    | None -> null)
    (if input_g then 1 else 0)
    (if weight_g then 1 else 0)
    (if bias_g then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  let t3 = CArray.get out__ 3 in
  Gc.finalise C.Tensor.free t3;
  t0, t1, t2, t3

let batch_norm_elemt input ~weight ~bias ~mean ~invstd ~eps =
  let out__ = CArray.make t 1 in
  stubs_batch_norm_elemt
    (CArray.start out__)
    input
    (match weight with
    | Some v -> v
    | None -> null)
    (match bias with
    | Some v -> v
    | None -> null)
    mean
    invstd
    eps;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let batch_norm_elemt_out ~out input ~weight ~bias ~mean ~invstd ~eps =
  let out__ = CArray.make t 1 in
  stubs_batch_norm_elemt_out
    (CArray.start out__)
    out
    input
    (match weight with
    | Some v -> v
    | None -> null)
    (match bias with
    | Some v -> v
    | None -> null)
    mean
    invstd
    eps;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let batch_norm_gather_stats
    input
    ~mean
    ~invstd
    ~running_mean
    ~running_var
    ~momentum
    ~eps
    ~count
  =
  let out__ = CArray.make t 2 in
  stubs_batch_norm_gather_stats
    (CArray.start out__)
    input
    mean
    invstd
    (match running_mean with
    | Some v -> v
    | None -> null)
    (match running_var with
    | Some v -> v
    | None -> null)
    momentum
    eps
    (Int64.of_int count);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let batch_norm_gather_stats_with_counts
    input
    ~mean
    ~invstd
    ~running_mean
    ~running_var
    ~momentum
    ~eps
    ~counts
  =
  let out__ = CArray.make t 2 in
  stubs_batch_norm_gather_stats_with_counts
    (CArray.start out__)
    input
    mean
    invstd
    (match running_mean with
    | Some v -> v
    | None -> null)
    (match running_var with
    | Some v -> v
    | None -> null)
    momentum
    eps
    counts;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let batch_norm_stats input ~eps =
  let out__ = CArray.make t 2 in
  stubs_batch_norm_stats (CArray.start out__) input eps;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let batch_norm_update_stats input ~running_mean ~running_var ~momentum =
  let out__ = CArray.make t 2 in
  stubs_batch_norm_update_stats
    (CArray.start out__)
    input
    (match running_mean with
    | Some v -> v
    | None -> null)
    (match running_var with
    | Some v -> v
    | None -> null)
    momentum;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let bernoulli self =
  let out__ = CArray.make t 1 in
  stubs_bernoulli (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bernoulli1 self ~p =
  let out__ = CArray.make t 1 in
  stubs_bernoulli1 (CArray.start out__) self p;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bernoulli_ self ~p =
  let out__ = CArray.make t 1 in
  stubs_bernoulli_ (CArray.start out__) self p;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bernoulli_1 self ~p =
  let out__ = CArray.make t 1 in
  stubs_bernoulli_1 (CArray.start out__) self p;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bernoulli_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_bernoulli_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bilinear ~input1 ~input2 ~weight ~bias =
  let out__ = CArray.make t 1 in
  stubs_bilinear
    (CArray.start out__)
    input1
    input2
    weight
    (match bias with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let binary_cross_entropy self ~target ~weight ~reduction =
  let out__ = CArray.make t 1 in
  stubs_binary_cross_entropy
    (CArray.start out__)
    self
    target
    (match weight with
    | Some v -> v
    | None -> null)
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let binary_cross_entropy_backward ~grad_output self ~target ~weight ~reduction =
  let out__ = CArray.make t 1 in
  stubs_binary_cross_entropy_backward
    (CArray.start out__)
    grad_output
    self
    target
    (match weight with
    | Some v -> v
    | None -> null)
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let binary_cross_entropy_backward_out
    ~grad_input
    ~grad_output
    self
    ~target
    ~weight
    ~reduction
  =
  let out__ = CArray.make t 1 in
  stubs_binary_cross_entropy_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    target
    (match weight with
    | Some v -> v
    | None -> null)
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let binary_cross_entropy_out ~out self ~target ~weight ~reduction =
  let out__ = CArray.make t 1 in
  stubs_binary_cross_entropy_out
    (CArray.start out__)
    out
    self
    target
    (match weight with
    | Some v -> v
    | None -> null)
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let binary_cross_entropy_with_logits self ~target ~weight ~pos_weight ~reduction =
  let out__ = CArray.make t 1 in
  stubs_binary_cross_entropy_with_logits
    (CArray.start out__)
    self
    target
    (match weight with
    | Some v -> v
    | None -> null)
    (match pos_weight with
    | Some v -> v
    | None -> null)
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let binary_cross_entropy_with_logits_backward
    ~grad_output
    self
    ~target
    ~weight
    ~pos_weight
    ~reduction
  =
  let out__ = CArray.make t 1 in
  stubs_binary_cross_entropy_with_logits_backward
    (CArray.start out__)
    grad_output
    self
    target
    (match weight with
    | Some v -> v
    | None -> null)
    (match pos_weight with
    | Some v -> v
    | None -> null)
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bincount self ~weights ~minlength =
  let out__ = CArray.make t 1 in
  stubs_bincount
    (CArray.start out__)
    self
    (match weights with
    | Some v -> v
    | None -> null)
    (Int64.of_int minlength);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let binomial ~count ~prob =
  let out__ = CArray.make t 1 in
  stubs_binomial (CArray.start out__) count prob;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bitwise_and self other =
  let out__ = CArray.make t 1 in
  stubs_bitwise_and (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bitwise_and_ self other =
  let out__ = CArray.make t 1 in
  stubs_bitwise_and_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bitwise_and_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_bitwise_and_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bitwise_not self =
  let out__ = CArray.make t 1 in
  stubs_bitwise_not (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bitwise_not_ self =
  let out__ = CArray.make t 1 in
  stubs_bitwise_not_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bitwise_not_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_bitwise_not_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bitwise_or self other =
  let out__ = CArray.make t 1 in
  stubs_bitwise_or (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bitwise_or_ self other =
  let out__ = CArray.make t 1 in
  stubs_bitwise_or_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bitwise_or_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_bitwise_or_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bitwise_xor self other =
  let out__ = CArray.make t 1 in
  stubs_bitwise_xor (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bitwise_xor_ self other =
  let out__ = CArray.make t 1 in
  stubs_bitwise_xor_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bitwise_xor_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_bitwise_xor_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let blackman_window ~window_length ~options =
  let out__ = CArray.make t 1 in
  stubs_blackman_window
    (CArray.start out__)
    (Int64.of_int window_length)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let blackman_window1 ~window_length ~periodic ~options =
  let out__ = CArray.make t 1 in
  stubs_blackman_window1
    (CArray.start out__)
    (Int64.of_int window_length)
    (if periodic then 1 else 0)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let block_diag tensors =
  let out__ = CArray.make t 1 in
  stubs_block_diag
    (CArray.start out__)
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bmm self ~mat2 =
  let out__ = CArray.make t 1 in
  stubs_bmm (CArray.start out__) self mat2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bmm_out ~out self ~mat2 =
  let out__ = CArray.make t 1 in
  stubs_bmm_out (CArray.start out__) out self mat2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let broadcast_tensors tensors =
  stubs_broadcast_tensors (CArray.of_list t tensors |> CArray.start) (List.length tensors)
  |> to_tensor_list

let broadcast_to self ~size =
  let out__ = CArray.make t 1 in
  stubs_broadcast_to
    (CArray.start out__)
    self
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bucketize self ~boundaries ~out_int32 ~right =
  let out__ = CArray.make t 1 in
  stubs_bucketize
    (CArray.start out__)
    self
    boundaries
    (if out_int32 then 1 else 0)
    (if right then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let bucketize_out ~out self ~boundaries ~out_int32 ~right =
  let out__ = CArray.make t 1 in
  stubs_bucketize_out
    (CArray.start out__)
    out
    self
    boundaries
    (if out_int32 then 1 else 0)
    (if right then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cartesian_prod tensors =
  let out__ = CArray.make t 1 in
  stubs_cartesian_prod
    (CArray.start out__)
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cat tensors ~dim =
  let out__ = CArray.make t 1 in
  stubs_cat
    (CArray.start out__)
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors)
    (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cat_out ~out tensors ~dim =
  let out__ = CArray.make t 1 in
  stubs_cat_out
    (CArray.start out__)
    out
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors)
    (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cauchy_ self ~median ~sigma =
  let out__ = CArray.make t 1 in
  stubs_cauchy_ (CArray.start out__) self median sigma;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cdist ~x1 ~x2 ~p ~compute_mode =
  let out__ = CArray.make t 1 in
  stubs_cdist (CArray.start out__) x1 x2 p (Int64.of_int compute_mode);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ceil self =
  let out__ = CArray.make t 1 in
  stubs_ceil (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ceil_ self =
  let out__ = CArray.make t 1 in
  stubs_ceil_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ceil_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_ceil_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let celu self =
  let out__ = CArray.make t 1 in
  stubs_celu (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let celu_ self =
  let out__ = CArray.make t 1 in
  stubs_celu_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let chain_matmul ~matrices =
  let out__ = CArray.make t 1 in
  stubs_chain_matmul
    (CArray.start out__)
    (CArray.of_list t matrices |> CArray.start)
    (List.length matrices);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let chain_matmul_out ~out ~matrices =
  let out__ = CArray.make t 1 in
  stubs_chain_matmul_out
    (CArray.start out__)
    out
    (CArray.of_list t matrices |> CArray.start)
    (List.length matrices);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let channel_shuffle self ~groups =
  let out__ = CArray.make t 1 in
  stubs_channel_shuffle (CArray.start out__) self (Int64.of_int groups);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cholesky self ~upper =
  let out__ = CArray.make t 1 in
  stubs_cholesky (CArray.start out__) self (if upper then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cholesky_inverse self ~upper =
  let out__ = CArray.make t 1 in
  stubs_cholesky_inverse (CArray.start out__) self (if upper then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cholesky_inverse_out ~out self ~upper =
  let out__ = CArray.make t 1 in
  stubs_cholesky_inverse_out (CArray.start out__) out self (if upper then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cholesky_out ~out self ~upper =
  let out__ = CArray.make t 1 in
  stubs_cholesky_out (CArray.start out__) out self (if upper then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cholesky_solve self ~input2 ~upper =
  let out__ = CArray.make t 1 in
  stubs_cholesky_solve (CArray.start out__) self input2 (if upper then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cholesky_solve_out ~out self ~input2 ~upper =
  let out__ = CArray.make t 1 in
  stubs_cholesky_solve_out (CArray.start out__) out self input2 (if upper then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let choose_qparams_optimized input ~numel ~n_bins ~ratio ~bit_width =
  let out__ = CArray.make t 2 in
  stubs_choose_qparams_optimized
    (CArray.start out__)
    input
    (Int64.of_int numel)
    (Int64.of_int n_bins)
    ratio
    (Int64.of_int bit_width);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let chunk self ~chunks ~dim =
  stubs_chunk self (Int64.of_int chunks) (Int64.of_int dim) |> to_tensor_list

let clamp self =
  let out__ = CArray.make t 1 in
  stubs_clamp (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let clamp1 self ~min ~max =
  let out__ = CArray.make t 1 in
  stubs_clamp1
    (CArray.start out__)
    self
    (match min with
    | Some v -> v
    | None -> null)
    (match max with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let clamp_ self =
  let out__ = CArray.make t 1 in
  stubs_clamp_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let clamp_1 self ~min ~max =
  let out__ = CArray.make t 1 in
  stubs_clamp_1
    (CArray.start out__)
    self
    (match min with
    | Some v -> v
    | None -> null)
    (match max with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let clamp_max self ~max =
  let out__ = CArray.make t 1 in
  stubs_clamp_max (CArray.start out__) self max;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let clamp_max_ self ~max =
  let out__ = CArray.make t 1 in
  stubs_clamp_max_ (CArray.start out__) self max;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let clamp_max_out ~out self ~max =
  let out__ = CArray.make t 1 in
  stubs_clamp_max_out (CArray.start out__) out self max;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let clamp_min self ~min =
  let out__ = CArray.make t 1 in
  stubs_clamp_min (CArray.start out__) self min;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let clamp_min_ self ~min =
  let out__ = CArray.make t 1 in
  stubs_clamp_min_ (CArray.start out__) self min;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let clamp_min_out ~out self ~min =
  let out__ = CArray.make t 1 in
  stubs_clamp_min_out (CArray.start out__) out self min;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let clamp_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_clamp_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let clamp_out1 ~out self ~min ~max =
  let out__ = CArray.make t 1 in
  stubs_clamp_out1
    (CArray.start out__)
    out
    self
    (match min with
    | Some v -> v
    | None -> null)
    (match max with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let clip self =
  let out__ = CArray.make t 1 in
  stubs_clip (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let clip1 self ~min ~max =
  let out__ = CArray.make t 1 in
  stubs_clip1
    (CArray.start out__)
    self
    (match min with
    | Some v -> v
    | None -> null)
    (match max with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let clip_ self =
  let out__ = CArray.make t 1 in
  stubs_clip_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let clip_1 self ~min ~max =
  let out__ = CArray.make t 1 in
  stubs_clip_1
    (CArray.start out__)
    self
    (match min with
    | Some v -> v
    | None -> null)
    (match max with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let clip_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_clip_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let clip_out1 ~out self ~min ~max =
  let out__ = CArray.make t 1 in
  stubs_clip_out1
    (CArray.start out__)
    out
    self
    (match min with
    | Some v -> v
    | None -> null)
    (match max with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let clone self =
  let out__ = CArray.make t 1 in
  stubs_clone (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let coalesce self =
  let out__ = CArray.make t 1 in
  stubs_coalesce (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let col2im self ~output_size ~kernel_size ~dilation ~padding ~stride =
  let out__ = CArray.make t 1 in
  stubs_col2im
    (CArray.start out__)
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let col2im_backward ~grad_output ~kernel_size ~dilation ~padding ~stride =
  let out__ = CArray.make t 1 in
  stubs_col2im_backward
    (CArray.start out__)
    grad_output
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let col2im_backward_out ~grad_input ~grad_output ~kernel_size ~dilation ~padding ~stride =
  let out__ = CArray.make t 1 in
  stubs_col2im_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let col2im_out ~out self ~output_size ~kernel_size ~dilation ~padding ~stride =
  let out__ = CArray.make t 1 in
  stubs_col2im_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let col_indices self =
  let out__ = CArray.make t 1 in
  stubs_col_indices (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let column_stack tensors =
  let out__ = CArray.make t 1 in
  stubs_column_stack
    (CArray.start out__)
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let column_stack_out ~out tensors =
  let out__ = CArray.make t 1 in
  stubs_column_stack_out
    (CArray.start out__)
    out
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let combinations self ~r ~with_replacement =
  let out__ = CArray.make t 1 in
  stubs_combinations
    (CArray.start out__)
    self
    (Int64.of_int r)
    (if with_replacement then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let complex ~real ~imag =
  let out__ = CArray.make t 1 in
  stubs_complex (CArray.start out__) real imag;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let complex_out ~out ~real ~imag =
  let out__ = CArray.make t 1 in
  stubs_complex_out (CArray.start out__) out real imag;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let conj self =
  let out__ = CArray.make t 1 in
  stubs_conj (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let conj_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_conj_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let constant_pad_nd self ~pad =
  let out__ = CArray.make t 1 in
  stubs_constant_pad_nd
    (CArray.start out__)
    self
    (List.map Int64.of_int pad |> CArray.of_list int64_t |> CArray.start)
    (List.length pad);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let contiguous self =
  let out__ = CArray.make t 1 in
  stubs_contiguous (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let conv1d input ~weight ~bias ~stride ~padding ~dilation ~groups =
  let out__ = CArray.make t 1 in
  stubs_conv1d
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let conv1d1 input ~weight ~bias ~stride ~padding ~dilation ~groups =
  let out__ = CArray.make t 1 in
  stubs_conv1d1
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    padding
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let conv2d input ~weight ~bias ~stride ~padding ~dilation ~groups =
  let out__ = CArray.make t 1 in
  stubs_conv2d
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let conv2d1 input ~weight ~bias ~stride ~padding ~dilation ~groups =
  let out__ = CArray.make t 1 in
  stubs_conv2d1
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    padding
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let conv3d input ~weight ~bias ~stride ~padding ~dilation ~groups =
  let out__ = CArray.make t 1 in
  stubs_conv3d
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let conv3d1 input ~weight ~bias ~stride ~padding ~dilation ~groups =
  let out__ = CArray.make t 1 in
  stubs_conv3d1
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    padding
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let conv_depthwise3d self ~weight ~kernel_size ~bias ~stride ~padding ~dilation =
  let out__ = CArray.make t 1 in
  stubs_conv_depthwise3d
    (CArray.start out__)
    self
    weight
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let conv_depthwise3d_backward_out
    ~grad_input
    ~grad_weight
    ~grad_bias
    ~grad_output
    self
    ~weight
    ~kernel_size
    ~stride
    ~padding
    ~dilation
  =
  let out__ = CArray.make t 3 in
  stubs_conv_depthwise3d_backward_out
    (CArray.start out__)
    grad_input
    grad_weight
    grad_bias
    grad_output
    self
    weight
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let conv_tbc self ~weight ~bias ~pad =
  let out__ = CArray.make t 1 in
  stubs_conv_tbc (CArray.start out__) self weight bias (Int64.of_int pad);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let conv_tbc_backward self input ~weight ~bias ~pad =
  let out__ = CArray.make t 3 in
  stubs_conv_tbc_backward (CArray.start out__) self input weight bias (Int64.of_int pad);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let conv_transpose1d
    input
    ~weight
    ~bias
    ~stride
    ~padding
    ~output_padding
    ~groups
    ~dilation
  =
  let out__ = CArray.make t 1 in
  stubs_conv_transpose1d
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int output_padding |> CArray.of_list int64_t |> CArray.start)
    (List.length output_padding)
    (Int64.of_int groups)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let conv_transpose2d
    input
    ~weight
    ~bias
    ~stride
    ~padding
    ~output_padding
    ~groups
    ~dilation
  =
  let out__ = CArray.make t 1 in
  stubs_conv_transpose2d
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int output_padding |> CArray.of_list int64_t |> CArray.start)
    (List.length output_padding)
    (Int64.of_int groups)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let conv_transpose3d
    input
    ~weight
    ~bias
    ~stride
    ~padding
    ~output_padding
    ~groups
    ~dilation
  =
  let out__ = CArray.make t 1 in
  stubs_conv_transpose3d
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int output_padding |> CArray.of_list int64_t |> CArray.start)
    (List.length output_padding)
    (Int64.of_int groups)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let convolution
    input
    ~weight
    ~bias
    ~stride
    ~padding
    ~dilation
    ~transposed
    ~output_padding
    ~groups
  =
  let out__ = CArray.make t 1 in
  stubs_convolution
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if transposed then 1 else 0)
    (List.map Int64.of_int output_padding |> CArray.of_list int64_t |> CArray.start)
    (List.length output_padding)
    (Int64.of_int groups);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let convolution_overrideable
    input
    ~weight
    ~bias
    ~stride
    ~padding
    ~dilation
    ~transposed
    ~output_padding
    ~groups
  =
  let out__ = CArray.make t 1 in
  stubs_convolution_overrideable
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if transposed then 1 else 0)
    (List.map Int64.of_int output_padding |> CArray.of_list int64_t |> CArray.start)
    (List.length output_padding)
    (Int64.of_int groups);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let copy_sparse_to_sparse_ self ~src ~non_blocking =
  let out__ = CArray.make t 1 in
  stubs_copy_sparse_to_sparse_
    (CArray.start out__)
    self
    src
    (if non_blocking then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let copysign self other =
  let out__ = CArray.make t 1 in
  stubs_copysign (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let copysign_ self other =
  let out__ = CArray.make t 1 in
  stubs_copysign_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let copysign_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_copysign_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cos self =
  let out__ = CArray.make t 1 in
  stubs_cos (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cos_ self =
  let out__ = CArray.make t 1 in
  stubs_cos_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cos_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_cos_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cosh self =
  let out__ = CArray.make t 1 in
  stubs_cosh (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cosh_ self =
  let out__ = CArray.make t 1 in
  stubs_cosh_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cosh_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_cosh_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cosine_embedding_loss ~input1 ~input2 ~target ~margin ~reduction =
  let out__ = CArray.make t 1 in
  stubs_cosine_embedding_loss
    (CArray.start out__)
    input1
    input2
    target
    margin
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cosine_similarity ~x1 ~x2 ~dim ~eps =
  let out__ = CArray.make t 1 in
  stubs_cosine_similarity (CArray.start out__) x1 x2 (Int64.of_int dim) eps;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cross self other ~dim =
  let out__ = CArray.make t 1 in
  stubs_cross (CArray.start out__) self other (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cross_entropy_loss self ~target ~weight ~reduction ~ignore_index =
  let out__ = CArray.make t 1 in
  stubs_cross_entropy_loss
    (CArray.start out__)
    self
    target
    (match weight with
    | Some v -> v
    | None -> null)
    (Reduction.to_int reduction |> Int64.of_int)
    (Int64.of_int ignore_index);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cross_out ~out self other ~dim =
  let out__ = CArray.make t 1 in
  stubs_cross_out (CArray.start out__) out self other (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let crow_indices self =
  let out__ = CArray.make t 1 in
  stubs_crow_indices (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ctc_loss
    ~log_probs
    ~targets
    ~input_lengths
    ~target_lengths
    ~blank
    ~reduction
    ~zero_infinity
  =
  let out__ = CArray.make t 1 in
  stubs_ctc_loss
    (CArray.start out__)
    log_probs
    targets
    (List.map Int64.of_int input_lengths |> CArray.of_list int64_t |> CArray.start)
    (List.length input_lengths)
    (List.map Int64.of_int target_lengths |> CArray.of_list int64_t |> CArray.start)
    (List.length target_lengths)
    (Int64.of_int blank)
    (Reduction.to_int reduction |> Int64.of_int)
    (if zero_infinity then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ctc_loss1
    ~log_probs
    ~targets
    ~input_lengths
    ~target_lengths
    ~blank
    ~reduction
    ~zero_infinity
  =
  let out__ = CArray.make t 1 in
  stubs_ctc_loss1
    (CArray.start out__)
    log_probs
    targets
    input_lengths
    target_lengths
    (Int64.of_int blank)
    (Reduction.to_int reduction |> Int64.of_int)
    (if zero_infinity then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cudnn_affine_grid_generator ~theta ~n ~c ~h ~w =
  let out__ = CArray.make t 1 in
  stubs_cudnn_affine_grid_generator
    (CArray.start out__)
    theta
    (Int64.of_int n)
    (Int64.of_int c)
    (Int64.of_int h)
    (Int64.of_int w);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cudnn_affine_grid_generator_backward ~grad ~n ~c ~h ~w =
  let out__ = CArray.make t 1 in
  stubs_cudnn_affine_grid_generator_backward
    (CArray.start out__)
    grad
    (Int64.of_int n)
    (Int64.of_int c)
    (Int64.of_int h)
    (Int64.of_int w);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cudnn_batch_norm
    input
    ~weight
    ~bias
    ~running_mean
    ~running_var
    ~training
    ~exponential_average_factor
    ~epsilon
  =
  let out__ = CArray.make t 4 in
  stubs_cudnn_batch_norm
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (match running_mean with
    | Some v -> v
    | None -> null)
    (match running_var with
    | Some v -> v
    | None -> null)
    (if training then 1 else 0)
    exponential_average_factor
    epsilon;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  let t3 = CArray.get out__ 3 in
  Gc.finalise C.Tensor.free t3;
  t0, t1, t2, t3

let cudnn_batch_norm_backward
    input
    ~grad_output
    ~weight
    ~running_mean
    ~running_var
    ~save_mean
    ~save_var
    ~epsilon
    ~reservespace
  =
  let out__ = CArray.make t 3 in
  stubs_cudnn_batch_norm_backward
    (CArray.start out__)
    input
    grad_output
    weight
    (match running_mean with
    | Some v -> v
    | None -> null)
    (match running_var with
    | Some v -> v
    | None -> null)
    (match save_mean with
    | Some v -> v
    | None -> null)
    (match save_var with
    | Some v -> v
    | None -> null)
    epsilon
    reservespace;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let cudnn_convolution
    self
    ~weight
    ~padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
  =
  let out__ = CArray.make t 1 in
  stubs_cudnn_convolution
    (CArray.start out__)
    self
    weight
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cudnn_convolution1
    self
    ~weight
    ~bias
    ~padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
  =
  let out__ = CArray.make t 1 in
  stubs_cudnn_convolution1
    (CArray.start out__)
    self
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cudnn_convolution2
    self
    ~weight
    ~padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
    ~allow_tf32
  =
  let out__ = CArray.make t 1 in
  stubs_cudnn_convolution2
    (CArray.start out__)
    self
    weight
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0)
    (if allow_tf32 then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cudnn_convolution_backward_input
    ~self_size
    ~grad_output
    ~weight
    ~padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
    ~allow_tf32
  =
  let out__ = CArray.make t 1 in
  stubs_cudnn_convolution_backward_input
    (CArray.start out__)
    (List.map Int64.of_int self_size |> CArray.of_list int64_t |> CArray.start)
    (List.length self_size)
    grad_output
    weight
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0)
    (if allow_tf32 then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cudnn_convolution_backward_weight
    ~weight_size
    ~grad_output
    self
    ~padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
    ~allow_tf32
  =
  let out__ = CArray.make t 1 in
  stubs_cudnn_convolution_backward_weight
    (CArray.start out__)
    (List.map Int64.of_int weight_size |> CArray.of_list int64_t |> CArray.start)
    (List.length weight_size)
    grad_output
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0)
    (if allow_tf32 then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cudnn_convolution_relu self ~weight ~bias ~stride ~padding ~dilation ~groups =
  let out__ = CArray.make t 1 in
  stubs_cudnn_convolution_relu
    (CArray.start out__)
    self
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cudnn_convolution_transpose
    self
    ~weight
    ~padding
    ~output_padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
  =
  let out__ = CArray.make t 1 in
  stubs_cudnn_convolution_transpose
    (CArray.start out__)
    self
    weight
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int output_padding |> CArray.of_list int64_t |> CArray.start)
    (List.length output_padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cudnn_convolution_transpose1
    self
    ~weight
    ~bias
    ~padding
    ~output_padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
  =
  let out__ = CArray.make t 1 in
  stubs_cudnn_convolution_transpose1
    (CArray.start out__)
    self
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int output_padding |> CArray.of_list int64_t |> CArray.start)
    (List.length output_padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cudnn_convolution_transpose2
    self
    ~weight
    ~padding
    ~output_padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
    ~allow_tf32
  =
  let out__ = CArray.make t 1 in
  stubs_cudnn_convolution_transpose2
    (CArray.start out__)
    self
    weight
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int output_padding |> CArray.of_list int64_t |> CArray.start)
    (List.length output_padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0)
    (if allow_tf32 then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cudnn_convolution_transpose_backward_input
    ~grad_output
    ~weight
    ~padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
    ~allow_tf32
  =
  let out__ = CArray.make t 1 in
  stubs_cudnn_convolution_transpose_backward_input
    (CArray.start out__)
    grad_output
    weight
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0)
    (if allow_tf32 then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cudnn_convolution_transpose_backward_weight
    ~weight_size
    ~grad_output
    self
    ~padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
    ~allow_tf32
  =
  let out__ = CArray.make t 1 in
  stubs_cudnn_convolution_transpose_backward_weight
    (CArray.start out__)
    (List.map Int64.of_int weight_size |> CArray.of_list int64_t |> CArray.start)
    (List.length weight_size)
    grad_output
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0)
    (if allow_tf32 then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cudnn_grid_sampler self ~grid =
  let out__ = CArray.make t 1 in
  stubs_cudnn_grid_sampler (CArray.start out__) self grid;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cudnn_grid_sampler_backward self ~grid ~grad_output =
  let out__ = CArray.make t 2 in
  stubs_cudnn_grid_sampler_backward (CArray.start out__) self grid grad_output;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let cummax self ~dim =
  let out__ = CArray.make t 2 in
  stubs_cummax (CArray.start out__) self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let cummax_out ~values ~indices self ~dim =
  let out__ = CArray.make t 2 in
  stubs_cummax_out (CArray.start out__) values indices self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let cummaxmin_backward ~grad input ~indices ~dim =
  let out__ = CArray.make t 1 in
  stubs_cummaxmin_backward (CArray.start out__) grad input indices (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cummin self ~dim =
  let out__ = CArray.make t 2 in
  stubs_cummin (CArray.start out__) self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let cummin_out ~values ~indices self ~dim =
  let out__ = CArray.make t 2 in
  stubs_cummin_out (CArray.start out__) values indices self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let cumprod self ~dim ~dtype =
  let out__ = CArray.make t 1 in
  stubs_cumprod (CArray.start out__) self (Int64.of_int dim) (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cumprod_ self ~dim ~dtype =
  let out__ = CArray.make t 1 in
  stubs_cumprod_ (CArray.start out__) self (Int64.of_int dim) (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cumprod_backward ~grad input ~dim ~output =
  let out__ = CArray.make t 1 in
  stubs_cumprod_backward (CArray.start out__) grad input (Int64.of_int dim) output;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cumprod_out ~out self ~dim ~dtype =
  let out__ = CArray.make t 1 in
  stubs_cumprod_out
    (CArray.start out__)
    out
    self
    (Int64.of_int dim)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cumsum self ~dim ~dtype =
  let out__ = CArray.make t 1 in
  stubs_cumsum (CArray.start out__) self (Int64.of_int dim) (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cumsum_ self ~dim ~dtype =
  let out__ = CArray.make t 1 in
  stubs_cumsum_ (CArray.start out__) self (Int64.of_int dim) (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let cumsum_out ~out self ~dim ~dtype =
  let out__ = CArray.make t 1 in
  stubs_cumsum_out
    (CArray.start out__)
    out
    self
    (Int64.of_int dim)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let data self =
  let out__ = CArray.make t 1 in
  stubs_data (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let deg2rad self =
  let out__ = CArray.make t 1 in
  stubs_deg2rad (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let deg2rad_ self =
  let out__ = CArray.make t 1 in
  stubs_deg2rad_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let deg2rad_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_deg2rad_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let dequantize self =
  let out__ = CArray.make t 1 in
  stubs_dequantize (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let dequantize1 tensors =
  stubs_dequantize1 (CArray.of_list t tensors |> CArray.start) (List.length tensors)
  |> to_tensor_list

let det self =
  let out__ = CArray.make t 1 in
  stubs_det (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let detach self =
  let out__ = CArray.make t 1 in
  stubs_detach (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let detach_ self =
  let out__ = CArray.make t 1 in
  stubs_detach_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let diag self ~diagonal =
  let out__ = CArray.make t 1 in
  stubs_diag (CArray.start out__) self (Int64.of_int diagonal);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let diag_backward ~grad ~input_sizes ~diagonal =
  let out__ = CArray.make t 1 in
  stubs_diag_backward
    (CArray.start out__)
    grad
    (List.map Int64.of_int input_sizes |> CArray.of_list int64_t |> CArray.start)
    (List.length input_sizes)
    (Int64.of_int diagonal);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let diag_embed self ~offset ~dim1 ~dim2 =
  let out__ = CArray.make t 1 in
  stubs_diag_embed
    (CArray.start out__)
    self
    (Int64.of_int offset)
    (Int64.of_int dim1)
    (Int64.of_int dim2);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let diag_out ~out self ~diagonal =
  let out__ = CArray.make t 1 in
  stubs_diag_out (CArray.start out__) out self (Int64.of_int diagonal);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let diagflat self ~offset =
  let out__ = CArray.make t 1 in
  stubs_diagflat (CArray.start out__) self (Int64.of_int offset);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let diagonal self ~offset ~dim1 ~dim2 =
  let out__ = CArray.make t 1 in
  stubs_diagonal
    (CArray.start out__)
    self
    (Int64.of_int offset)
    (Int64.of_int dim1)
    (Int64.of_int dim2);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let diagonal_backward ~grad ~input_sizes ~offset ~dim1 ~dim2 =
  let out__ = CArray.make t 1 in
  stubs_diagonal_backward
    (CArray.start out__)
    grad
    (List.map Int64.of_int input_sizes |> CArray.of_list int64_t |> CArray.start)
    (List.length input_sizes)
    (Int64.of_int offset)
    (Int64.of_int dim1)
    (Int64.of_int dim2);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let diff self ~n ~dim ~prepend ~append =
  let out__ = CArray.make t 1 in
  stubs_diff
    (CArray.start out__)
    self
    (Int64.of_int n)
    (Int64.of_int dim)
    (match prepend with
    | Some v -> v
    | None -> null)
    (match append with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let diff_out ~out self ~n ~dim ~prepend ~append =
  let out__ = CArray.make t 1 in
  stubs_diff_out
    (CArray.start out__)
    out
    self
    (Int64.of_int n)
    (Int64.of_int dim)
    (match prepend with
    | Some v -> v
    | None -> null)
    (match append with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let digamma self =
  let out__ = CArray.make t 1 in
  stubs_digamma (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let digamma_ self =
  let out__ = CArray.make t 1 in
  stubs_digamma_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let digamma_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_digamma_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let dist self other =
  let out__ = CArray.make t 1 in
  stubs_dist (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let div self other =
  let out__ = CArray.make t 1 in
  stubs_div (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let div1 self other ~rounding_mode =
  let out__ = CArray.make t 1 in
  stubs_div1 (CArray.start out__) self other rounding_mode;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let div_ self other =
  let out__ = CArray.make t 1 in
  stubs_div_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let div_1 self other ~rounding_mode =
  let out__ = CArray.make t 1 in
  stubs_div_1 (CArray.start out__) self other rounding_mode;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let div_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_div_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let div_out1 ~out self other ~rounding_mode =
  let out__ = CArray.make t 1 in
  stubs_div_out1 (CArray.start out__) out self other rounding_mode;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let divide self other =
  let out__ = CArray.make t 1 in
  stubs_divide (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let divide1 self other ~rounding_mode =
  let out__ = CArray.make t 1 in
  stubs_divide1 (CArray.start out__) self other rounding_mode;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let divide_ self other =
  let out__ = CArray.make t 1 in
  stubs_divide_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let divide_1 self other ~rounding_mode =
  let out__ = CArray.make t 1 in
  stubs_divide_1 (CArray.start out__) self other rounding_mode;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let divide_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_divide_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let divide_out1 ~out self other ~rounding_mode =
  let out__ = CArray.make t 1 in
  stubs_divide_out1 (CArray.start out__) out self other rounding_mode;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let dot self tensor =
  let out__ = CArray.make t 1 in
  stubs_dot (CArray.start out__) self tensor;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let dot_out ~out self tensor =
  let out__ = CArray.make t 1 in
  stubs_dot_out (CArray.start out__) out self tensor;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let dropout input ~p ~train =
  let out__ = CArray.make t 1 in
  stubs_dropout (CArray.start out__) input p (if train then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let dropout_ self ~p ~train =
  let out__ = CArray.make t 1 in
  stubs_dropout_ (CArray.start out__) self p (if train then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let dsplit self ~sections = stubs_dsplit self (Int64.of_int sections) |> to_tensor_list

let dsplit1 self ~indices =
  stubs_dsplit1
    self
    (List.map Int64.of_int indices |> CArray.of_list int64_t |> CArray.start)
    (List.length indices)
  |> to_tensor_list

let dstack tensors =
  let out__ = CArray.make t 1 in
  stubs_dstack
    (CArray.start out__)
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let dstack_out ~out tensors =
  let out__ = CArray.make t 1 in
  stubs_dstack_out
    (CArray.start out__)
    out
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let eig self ~eigenvectors =
  let out__ = CArray.make t 2 in
  stubs_eig (CArray.start out__) self (if eigenvectors then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let eig_out ~e ~v self ~eigenvectors =
  let out__ = CArray.make t 2 in
  stubs_eig_out (CArray.start out__) e v self (if eigenvectors then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let einsum ~equation tensors =
  let out__ = CArray.make t 1 in
  stubs_einsum
    (CArray.start out__)
    equation
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let elu self =
  let out__ = CArray.make t 1 in
  stubs_elu (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let elu_ self =
  let out__ = CArray.make t 1 in
  stubs_elu_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let elu_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_elu_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let embedding ~weight ~indices ~padding_idx ~scale_grad_by_freq ~sparse =
  let out__ = CArray.make t 1 in
  stubs_embedding
    (CArray.start out__)
    weight
    indices
    (Int64.of_int padding_idx)
    (if scale_grad_by_freq then 1 else 0)
    (if sparse then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let embedding_backward
    ~grad
    ~indices
    ~num_weights
    ~padding_idx
    ~scale_grad_by_freq
    ~sparse
  =
  let out__ = CArray.make t 1 in
  stubs_embedding_backward
    (CArray.start out__)
    grad
    indices
    (Int64.of_int num_weights)
    (Int64.of_int padding_idx)
    (if scale_grad_by_freq then 1 else 0)
    (if sparse then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let embedding_bag
    ~weight
    ~indices
    ~offsets
    ~scale_grad_by_freq
    ~mode
    ~sparse
    ~per_sample_weights
    ~include_last_offset
  =
  let out__ = CArray.make t 4 in
  stubs_embedding_bag
    (CArray.start out__)
    weight
    indices
    offsets
    (if scale_grad_by_freq then 1 else 0)
    (Int64.of_int mode)
    (if sparse then 1 else 0)
    (match per_sample_weights with
    | Some v -> v
    | None -> null)
    (if include_last_offset then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  let t3 = CArray.get out__ 3 in
  Gc.finalise C.Tensor.free t3;
  t0, t1, t2, t3

let embedding_bag1
    ~weight
    ~indices
    ~offsets
    ~scale_grad_by_freq
    ~mode
    ~sparse
    ~per_sample_weights
    ~include_last_offset
    ~padding_idx
  =
  let out__ = CArray.make t 4 in
  stubs_embedding_bag1
    (CArray.start out__)
    weight
    indices
    offsets
    (if scale_grad_by_freq then 1 else 0)
    (Int64.of_int mode)
    (if sparse then 1 else 0)
    (match per_sample_weights with
    | Some v -> v
    | None -> null)
    (if include_last_offset then 1 else 0)
    (Int64.of_int padding_idx);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  let t3 = CArray.get out__ 3 in
  Gc.finalise C.Tensor.free t3;
  t0, t1, t2, t3

let embedding_dense_backward
    ~grad_output
    ~indices
    ~num_weights
    ~padding_idx
    ~scale_grad_by_freq
  =
  let out__ = CArray.make t 1 in
  stubs_embedding_dense_backward
    (CArray.start out__)
    grad_output
    indices
    (Int64.of_int num_weights)
    (Int64.of_int padding_idx)
    (if scale_grad_by_freq then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let embedding_renorm_ self ~indices ~max_norm ~norm_type =
  let out__ = CArray.make t 1 in
  stubs_embedding_renorm_ (CArray.start out__) self indices max_norm norm_type;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let embedding_sparse_backward ~grad ~indices ~num_weights ~padding_idx ~scale_grad_by_freq
  =
  let out__ = CArray.make t 1 in
  stubs_embedding_sparse_backward
    (CArray.start out__)
    grad
    indices
    (Int64.of_int num_weights)
    (Int64.of_int padding_idx)
    (if scale_grad_by_freq then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let empty ~size ~options =
  let out__ = CArray.make t 1 in
  stubs_empty
    (CArray.start out__)
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let empty_like self =
  let out__ = CArray.make t 1 in
  stubs_empty_like (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let empty_out ~out ~size =
  let out__ = CArray.make t 1 in
  stubs_empty_out
    (CArray.start out__)
    out
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let empty_quantized ~size ~qtensor =
  let out__ = CArray.make t 1 in
  stubs_empty_quantized
    (CArray.start out__)
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    qtensor;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let empty_strided ~size ~stride ~options =
  let out__ = CArray.make t 1 in
  stubs_empty_strided
    (CArray.start out__)
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let eq self other =
  let out__ = CArray.make t 1 in
  stubs_eq (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let eq_ self other =
  let out__ = CArray.make t 1 in
  stubs_eq_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let eq_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_eq_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let erf self =
  let out__ = CArray.make t 1 in
  stubs_erf (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let erf_ self =
  let out__ = CArray.make t 1 in
  stubs_erf_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let erf_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_erf_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let erfc self =
  let out__ = CArray.make t 1 in
  stubs_erfc (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let erfc_ self =
  let out__ = CArray.make t 1 in
  stubs_erfc_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let erfc_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_erfc_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let erfinv self =
  let out__ = CArray.make t 1 in
  stubs_erfinv (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let erfinv_ self =
  let out__ = CArray.make t 1 in
  stubs_erfinv_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let erfinv_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_erfinv_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let exp self =
  let out__ = CArray.make t 1 in
  stubs_exp (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let exp2 self =
  let out__ = CArray.make t 1 in
  stubs_exp2 (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let exp2_ self =
  let out__ = CArray.make t 1 in
  stubs_exp2_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let exp2_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_exp2_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let exp_ self =
  let out__ = CArray.make t 1 in
  stubs_exp_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let exp_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_exp_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let expand self ~size ~implicit =
  let out__ = CArray.make t 1 in
  stubs_expand
    (CArray.start out__)
    self
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (if implicit then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let expand_as self other =
  let out__ = CArray.make t 1 in
  stubs_expand_as (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let expm1 self =
  let out__ = CArray.make t 1 in
  stubs_expm1 (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let expm1_ self =
  let out__ = CArray.make t 1 in
  stubs_expm1_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let expm1_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_expm1_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let exponential_ self ~lambd =
  let out__ = CArray.make t 1 in
  stubs_exponential_ (CArray.start out__) self lambd;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let eye ~n ~options =
  let out__ = CArray.make t 1 in
  stubs_eye
    (CArray.start out__)
    (Int64.of_int n)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let eye1 ~n ~m ~options =
  let out__ = CArray.make t 1 in
  stubs_eye1
    (CArray.start out__)
    (Int64.of_int n)
    (Int64.of_int m)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let eye_out ~out ~n =
  let out__ = CArray.make t 1 in
  stubs_eye_out (CArray.start out__) out (Int64.of_int n);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let eye_out1 ~out ~n ~m =
  let out__ = CArray.make t 1 in
  stubs_eye_out1 (CArray.start out__) out (Int64.of_int n) (Int64.of_int m);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fake_quantize_per_channel_affine self ~scale ~zero_point ~axis ~quant_min ~quant_max =
  let out__ = CArray.make t 1 in
  stubs_fake_quantize_per_channel_affine
    (CArray.start out__)
    self
    scale
    zero_point
    (Int64.of_int axis)
    (Int64.of_int quant_min)
    (Int64.of_int quant_max);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fake_quantize_per_channel_affine_cachemask
    self
    ~scale
    ~zero_point
    ~axis
    ~quant_min
    ~quant_max
  =
  let out__ = CArray.make t 2 in
  stubs_fake_quantize_per_channel_affine_cachemask
    (CArray.start out__)
    self
    scale
    zero_point
    (Int64.of_int axis)
    (Int64.of_int quant_min)
    (Int64.of_int quant_max);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let fake_quantize_per_channel_affine_cachemask_backward ~grad ~mask =
  let out__ = CArray.make t 1 in
  stubs_fake_quantize_per_channel_affine_cachemask_backward (CArray.start out__) grad mask;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fake_quantize_per_tensor_affine self ~scale ~zero_point ~quant_min ~quant_max =
  let out__ = CArray.make t 1 in
  stubs_fake_quantize_per_tensor_affine
    (CArray.start out__)
    self
    scale
    (Int64.of_int zero_point)
    (Int64.of_int quant_min)
    (Int64.of_int quant_max);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fake_quantize_per_tensor_affine_cachemask
    self
    ~scale
    ~zero_point
    ~quant_min
    ~quant_max
  =
  let out__ = CArray.make t 2 in
  stubs_fake_quantize_per_tensor_affine_cachemask
    (CArray.start out__)
    self
    scale
    (Int64.of_int zero_point)
    (Int64.of_int quant_min)
    (Int64.of_int quant_max);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let fake_quantize_per_tensor_affine_cachemask_backward ~grad ~mask =
  let out__ = CArray.make t 1 in
  stubs_fake_quantize_per_tensor_affine_cachemask_backward (CArray.start out__) grad mask;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fbgemm_linear_fp16_weight input ~packed_weight ~bias =
  let out__ = CArray.make t 1 in
  stubs_fbgemm_linear_fp16_weight (CArray.start out__) input packed_weight bias;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fbgemm_linear_fp16_weight_fp32_activation input ~packed_weight ~bias =
  let out__ = CArray.make t 1 in
  stubs_fbgemm_linear_fp16_weight_fp32_activation
    (CArray.start out__)
    input
    packed_weight
    bias;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fbgemm_pack_gemm_matrix_fp16 input =
  let out__ = CArray.make t 1 in
  stubs_fbgemm_pack_gemm_matrix_fp16 (CArray.start out__) input;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fbgemm_pack_quantized_matrix input =
  let out__ = CArray.make t 1 in
  stubs_fbgemm_pack_quantized_matrix (CArray.start out__) input;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fbgemm_pack_quantized_matrix1 input ~k ~n =
  let out__ = CArray.make t 1 in
  stubs_fbgemm_pack_quantized_matrix1
    (CArray.start out__)
    input
    (Int64.of_int k)
    (Int64.of_int n);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let feature_alpha_dropout input ~p ~train =
  let out__ = CArray.make t 1 in
  stubs_feature_alpha_dropout (CArray.start out__) input p (if train then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let feature_alpha_dropout_ self ~p ~train =
  let out__ = CArray.make t 1 in
  stubs_feature_alpha_dropout_ (CArray.start out__) self p (if train then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let feature_dropout input ~p ~train =
  let out__ = CArray.make t 1 in
  stubs_feature_dropout (CArray.start out__) input p (if train then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let feature_dropout_ self ~p ~train =
  let out__ = CArray.make t 1 in
  stubs_feature_dropout_ (CArray.start out__) self p (if train then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_fft self ~n ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_fft (CArray.start out__) self (Int64.of_int n) (Int64.of_int dim) norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_fft2 self ~s ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_fft2
    (CArray.start out__)
    self
    (List.map Int64.of_int s |> CArray.of_list int64_t |> CArray.start)
    (List.length s)
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_fft2_out ~out self ~s ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_fft2_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int s |> CArray.of_list int64_t |> CArray.start)
    (List.length s)
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_fft_out ~out self ~n ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_fft_out (CArray.start out__) out self (Int64.of_int n) (Int64.of_int dim) norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_fftfreq ~n ~d ~options =
  let out__ = CArray.make t 1 in
  stubs_fft_fftfreq
    (CArray.start out__)
    (Int64.of_int n)
    d
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_fftfreq_out ~out ~n ~d =
  let out__ = CArray.make t 1 in
  stubs_fft_fftfreq_out (CArray.start out__) out (Int64.of_int n) d;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_fftn self ~s ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_fftn
    (CArray.start out__)
    self
    (List.map Int64.of_int s |> CArray.of_list int64_t |> CArray.start)
    (List.length s)
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_fftn_out ~out self ~s ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_fftn_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int s |> CArray.of_list int64_t |> CArray.start)
    (List.length s)
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_fftshift self ~dim =
  let out__ = CArray.make t 1 in
  stubs_fft_fftshift
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_hfft self ~n ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_hfft (CArray.start out__) self (Int64.of_int n) (Int64.of_int dim) norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_hfft_out ~out self ~n ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_hfft_out
    (CArray.start out__)
    out
    self
    (Int64.of_int n)
    (Int64.of_int dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_ifft self ~n ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_ifft (CArray.start out__) self (Int64.of_int n) (Int64.of_int dim) norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_ifft2 self ~s ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_ifft2
    (CArray.start out__)
    self
    (List.map Int64.of_int s |> CArray.of_list int64_t |> CArray.start)
    (List.length s)
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_ifft2_out ~out self ~s ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_ifft2_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int s |> CArray.of_list int64_t |> CArray.start)
    (List.length s)
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_ifft_out ~out self ~n ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_ifft_out
    (CArray.start out__)
    out
    self
    (Int64.of_int n)
    (Int64.of_int dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_ifftn self ~s ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_ifftn
    (CArray.start out__)
    self
    (List.map Int64.of_int s |> CArray.of_list int64_t |> CArray.start)
    (List.length s)
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_ifftn_out ~out self ~s ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_ifftn_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int s |> CArray.of_list int64_t |> CArray.start)
    (List.length s)
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_ifftshift self ~dim =
  let out__ = CArray.make t 1 in
  stubs_fft_ifftshift
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_ihfft self ~n ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_ihfft (CArray.start out__) self (Int64.of_int n) (Int64.of_int dim) norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_ihfft_out ~out self ~n ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_ihfft_out
    (CArray.start out__)
    out
    self
    (Int64.of_int n)
    (Int64.of_int dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_irfft self ~n ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_irfft (CArray.start out__) self (Int64.of_int n) (Int64.of_int dim) norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_irfft2 self ~s ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_irfft2
    (CArray.start out__)
    self
    (List.map Int64.of_int s |> CArray.of_list int64_t |> CArray.start)
    (List.length s)
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_irfft2_out ~out self ~s ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_irfft2_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int s |> CArray.of_list int64_t |> CArray.start)
    (List.length s)
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_irfft_out ~out self ~n ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_irfft_out
    (CArray.start out__)
    out
    self
    (Int64.of_int n)
    (Int64.of_int dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_irfftn self ~s ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_irfftn
    (CArray.start out__)
    self
    (List.map Int64.of_int s |> CArray.of_list int64_t |> CArray.start)
    (List.length s)
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_irfftn_out ~out self ~s ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_irfftn_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int s |> CArray.of_list int64_t |> CArray.start)
    (List.length s)
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_rfft self ~n ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_rfft (CArray.start out__) self (Int64.of_int n) (Int64.of_int dim) norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_rfft2 self ~s ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_rfft2
    (CArray.start out__)
    self
    (List.map Int64.of_int s |> CArray.of_list int64_t |> CArray.start)
    (List.length s)
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_rfft2_out ~out self ~s ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_rfft2_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int s |> CArray.of_list int64_t |> CArray.start)
    (List.length s)
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_rfft_out ~out self ~n ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_rfft_out
    (CArray.start out__)
    out
    self
    (Int64.of_int n)
    (Int64.of_int dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_rfftfreq ~n ~d ~options =
  let out__ = CArray.make t 1 in
  stubs_fft_rfftfreq
    (CArray.start out__)
    (Int64.of_int n)
    d
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_rfftfreq_out ~out ~n ~d =
  let out__ = CArray.make t 1 in
  stubs_fft_rfftfreq_out (CArray.start out__) out (Int64.of_int n) d;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_rfftn self ~s ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_rfftn
    (CArray.start out__)
    self
    (List.map Int64.of_int s |> CArray.of_list int64_t |> CArray.start)
    (List.length s)
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fft_rfftn_out ~out self ~s ~dim ~norm =
  let out__ = CArray.make t 1 in
  stubs_fft_rfftn_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int s |> CArray.of_list int64_t |> CArray.start)
    (List.length s)
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    norm;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fill_ self ~value =
  let out__ = CArray.make t 1 in
  stubs_fill_ (CArray.start out__) self value;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fix self =
  let out__ = CArray.make t 1 in
  stubs_fix (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fix_ self =
  let out__ = CArray.make t 1 in
  stubs_fix_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fix_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_fix_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let flatten self ~start_dim ~end_dim =
  let out__ = CArray.make t 1 in
  stubs_flatten (CArray.start out__) self (Int64.of_int start_dim) (Int64.of_int end_dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let flatten_dense_tensors tensors =
  let out__ = CArray.make t 1 in
  stubs_flatten_dense_tensors
    (CArray.start out__)
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let flip self ~dims =
  let out__ = CArray.make t 1 in
  stubs_flip
    (CArray.start out__)
    self
    (List.map Int64.of_int dims |> CArray.of_list int64_t |> CArray.start)
    (List.length dims);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fliplr self =
  let out__ = CArray.make t 1 in
  stubs_fliplr (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let flipud self =
  let out__ = CArray.make t 1 in
  stubs_flipud (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let float_power self ~exponent =
  let out__ = CArray.make t 1 in
  stubs_float_power (CArray.start out__) self exponent;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let float_power_ self ~exponent =
  let out__ = CArray.make t 1 in
  stubs_float_power_ (CArray.start out__) self exponent;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let float_power_out ~out self ~exponent =
  let out__ = CArray.make t 1 in
  stubs_float_power_out (CArray.start out__) out self exponent;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let floor self =
  let out__ = CArray.make t 1 in
  stubs_floor (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let floor_ self =
  let out__ = CArray.make t 1 in
  stubs_floor_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let floor_divide self other =
  let out__ = CArray.make t 1 in
  stubs_floor_divide (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let floor_divide_ self other =
  let out__ = CArray.make t 1 in
  stubs_floor_divide_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let floor_divide_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_floor_divide_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let floor_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_floor_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fmax self other =
  let out__ = CArray.make t 1 in
  stubs_fmax (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fmax_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_fmax_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fmin self other =
  let out__ = CArray.make t 1 in
  stubs_fmin (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fmin_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_fmin_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fmod self other =
  let out__ = CArray.make t 1 in
  stubs_fmod (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fmod_ self other =
  let out__ = CArray.make t 1 in
  stubs_fmod_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fmod_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_fmod_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let frac self =
  let out__ = CArray.make t 1 in
  stubs_frac (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let frac_ self =
  let out__ = CArray.make t 1 in
  stubs_frac_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let frac_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_frac_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fractional_max_pool2d self ~kernel_size ~output_size ~random_samples =
  let out__ = CArray.make t 2 in
  stubs_fractional_max_pool2d
    (CArray.start out__)
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    random_samples;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let fractional_max_pool2d_backward ~grad_output self ~kernel_size ~output_size ~indices =
  let out__ = CArray.make t 1 in
  stubs_fractional_max_pool2d_backward
    (CArray.start out__)
    grad_output
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    indices;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fractional_max_pool2d_backward_out
    ~grad_input
    ~grad_output
    self
    ~kernel_size
    ~output_size
    ~indices
  =
  let out__ = CArray.make t 1 in
  stubs_fractional_max_pool2d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    indices;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fractional_max_pool2d_out
    ~output
    ~indices
    self
    ~kernel_size
    ~output_size
    ~random_samples
  =
  let out__ = CArray.make t 2 in
  stubs_fractional_max_pool2d_out
    (CArray.start out__)
    output
    indices
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    random_samples;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let fractional_max_pool3d self ~kernel_size ~output_size ~random_samples =
  let out__ = CArray.make t 2 in
  stubs_fractional_max_pool3d
    (CArray.start out__)
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    random_samples;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let fractional_max_pool3d_backward ~grad_output self ~kernel_size ~output_size ~indices =
  let out__ = CArray.make t 1 in
  stubs_fractional_max_pool3d_backward
    (CArray.start out__)
    grad_output
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    indices;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fractional_max_pool3d_backward_out
    ~grad_input
    ~grad_output
    self
    ~kernel_size
    ~output_size
    ~indices
  =
  let out__ = CArray.make t 1 in
  stubs_fractional_max_pool3d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    indices;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let fractional_max_pool3d_out
    ~output
    ~indices
    self
    ~kernel_size
    ~output_size
    ~random_samples
  =
  let out__ = CArray.make t 2 in
  stubs_fractional_max_pool3d_out
    (CArray.start out__)
    output
    indices
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    random_samples;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let frexp self =
  let out__ = CArray.make t 2 in
  stubs_frexp (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let frexp_out ~mantissa ~exponent self =
  let out__ = CArray.make t 2 in
  stubs_frexp_out (CArray.start out__) mantissa exponent self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let frobenius_norm self =
  let out__ = CArray.make t 1 in
  stubs_frobenius_norm (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let frobenius_norm1 self ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_frobenius_norm1
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let frobenius_norm_out ~out self ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_frobenius_norm_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let from_file ~filename ~shared ~size ~options =
  let out__ = CArray.make t 1 in
  stubs_from_file
    (CArray.start out__)
    filename
    (if shared then 1 else 0)
    (Int64.of_int size)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let gather self ~dim ~index ~sparse_grad =
  let out__ = CArray.make t 1 in
  stubs_gather
    (CArray.start out__)
    self
    (Int64.of_int dim)
    index
    (if sparse_grad then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let gather_backward ~grad self ~dim ~index ~sparse_grad =
  let out__ = CArray.make t 1 in
  stubs_gather_backward
    (CArray.start out__)
    grad
    self
    (Int64.of_int dim)
    index
    (if sparse_grad then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let gather_out ~out self ~dim ~index ~sparse_grad =
  let out__ = CArray.make t 1 in
  stubs_gather_out
    (CArray.start out__)
    out
    self
    (Int64.of_int dim)
    index
    (if sparse_grad then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let gcd self other =
  let out__ = CArray.make t 1 in
  stubs_gcd (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let gcd_ self other =
  let out__ = CArray.make t 1 in
  stubs_gcd_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let gcd_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_gcd_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ge self other =
  let out__ = CArray.make t 1 in
  stubs_ge (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ge_ self other =
  let out__ = CArray.make t 1 in
  stubs_ge_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ge_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_ge_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let gelu self =
  let out__ = CArray.make t 1 in
  stubs_gelu (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let gelu_backward ~grad self =
  let out__ = CArray.make t 1 in
  stubs_gelu_backward (CArray.start out__) grad self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let geometric_ self ~p =
  let out__ = CArray.make t 1 in
  stubs_geometric_ (CArray.start out__) self p;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let geqrf self =
  let out__ = CArray.make t 2 in
  stubs_geqrf (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let geqrf_out ~a ~tau self =
  let out__ = CArray.make t 2 in
  stubs_geqrf_out (CArray.start out__) a tau self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let ger self ~vec2 =
  let out__ = CArray.make t 1 in
  stubs_ger (CArray.start out__) self vec2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ger_out ~out self ~vec2 =
  let out__ = CArray.make t 1 in
  stubs_ger_out (CArray.start out__) out self vec2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let glu self ~dim =
  let out__ = CArray.make t 1 in
  stubs_glu (CArray.start out__) self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let glu_backward ~grad_output self ~dim =
  let out__ = CArray.make t 1 in
  stubs_glu_backward (CArray.start out__) grad_output self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let glu_backward_out ~grad_input ~grad_output self ~dim =
  let out__ = CArray.make t 1 in
  stubs_glu_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let glu_out ~out self ~dim =
  let out__ = CArray.make t 1 in
  stubs_glu_out (CArray.start out__) out self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let grad self =
  let out__ = CArray.make t 1 in
  stubs_grad (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let greater self other =
  let out__ = CArray.make t 1 in
  stubs_greater (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let greater_ self other =
  let out__ = CArray.make t 1 in
  stubs_greater_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let greater_equal self other =
  let out__ = CArray.make t 1 in
  stubs_greater_equal (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let greater_equal_ self other =
  let out__ = CArray.make t 1 in
  stubs_greater_equal_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let greater_equal_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_greater_equal_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let greater_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_greater_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let grid_sampler input ~grid ~interpolation_mode ~padding_mode ~align_corners =
  let out__ = CArray.make t 1 in
  stubs_grid_sampler
    (CArray.start out__)
    input
    grid
    (Int64.of_int interpolation_mode)
    (Int64.of_int padding_mode)
    (if align_corners then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let grid_sampler_2d input ~grid ~interpolation_mode ~padding_mode ~align_corners =
  let out__ = CArray.make t 1 in
  stubs_grid_sampler_2d
    (CArray.start out__)
    input
    grid
    (Int64.of_int interpolation_mode)
    (Int64.of_int padding_mode)
    (if align_corners then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let grid_sampler_2d_backward
    ~grad_output
    input
    ~grid
    ~interpolation_mode
    ~padding_mode
    ~align_corners
  =
  let out__ = CArray.make t 2 in
  stubs_grid_sampler_2d_backward
    (CArray.start out__)
    grad_output
    input
    grid
    (Int64.of_int interpolation_mode)
    (Int64.of_int padding_mode)
    (if align_corners then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let grid_sampler_3d input ~grid ~interpolation_mode ~padding_mode ~align_corners =
  let out__ = CArray.make t 1 in
  stubs_grid_sampler_3d
    (CArray.start out__)
    input
    grid
    (Int64.of_int interpolation_mode)
    (Int64.of_int padding_mode)
    (if align_corners then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let grid_sampler_3d_backward
    ~grad_output
    input
    ~grid
    ~interpolation_mode
    ~padding_mode
    ~align_corners
  =
  let out__ = CArray.make t 2 in
  stubs_grid_sampler_3d_backward
    (CArray.start out__)
    grad_output
    input
    grid
    (Int64.of_int interpolation_mode)
    (Int64.of_int padding_mode)
    (if align_corners then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let group_norm input ~num_groups ~weight ~bias ~eps ~cudnn_enabled =
  let out__ = CArray.make t 1 in
  stubs_group_norm
    (CArray.start out__)
    input
    (Int64.of_int num_groups)
    (match weight with
    | Some v -> v
    | None -> null)
    (match bias with
    | Some v -> v
    | None -> null)
    eps
    (if cudnn_enabled then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let gru
    input
    ~hx
    ~params
    ~has_biases
    ~num_layers
    ~dropout
    ~train
    ~bidirectional
    ~batch_first
  =
  let out__ = CArray.make t 2 in
  stubs_gru
    (CArray.start out__)
    input
    hx
    (CArray.of_list t params |> CArray.start)
    (List.length params)
    (if has_biases then 1 else 0)
    (Int64.of_int num_layers)
    dropout
    (if train then 1 else 0)
    (if bidirectional then 1 else 0)
    (if batch_first then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let gru1
    ~data
    ~batch_sizes
    ~hx
    ~params
    ~has_biases
    ~num_layers
    ~dropout
    ~train
    ~bidirectional
  =
  let out__ = CArray.make t 2 in
  stubs_gru1
    (CArray.start out__)
    data
    batch_sizes
    hx
    (CArray.of_list t params |> CArray.start)
    (List.length params)
    (if has_biases then 1 else 0)
    (Int64.of_int num_layers)
    dropout
    (if train then 1 else 0)
    (if bidirectional then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let gru_cell input ~hx ~w_ih ~w_hh ~b_ih ~b_hh =
  let out__ = CArray.make t 1 in
  stubs_gru_cell
    (CArray.start out__)
    input
    hx
    w_ih
    w_hh
    (match b_ih with
    | Some v -> v
    | None -> null)
    (match b_hh with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let gt self other =
  let out__ = CArray.make t 1 in
  stubs_gt (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let gt_ self other =
  let out__ = CArray.make t 1 in
  stubs_gt_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let gt_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_gt_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hamming_window ~window_length ~options =
  let out__ = CArray.make t 1 in
  stubs_hamming_window
    (CArray.start out__)
    (Int64.of_int window_length)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hamming_window1 ~window_length ~periodic ~options =
  let out__ = CArray.make t 1 in
  stubs_hamming_window1
    (CArray.start out__)
    (Int64.of_int window_length)
    (if periodic then 1 else 0)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hamming_window2 ~window_length ~periodic ~alpha ~options =
  let out__ = CArray.make t 1 in
  stubs_hamming_window2
    (CArray.start out__)
    (Int64.of_int window_length)
    (if periodic then 1 else 0)
    alpha
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hamming_window3 ~window_length ~periodic ~alpha ~beta ~options =
  let out__ = CArray.make t 1 in
  stubs_hamming_window3
    (CArray.start out__)
    (Int64.of_int window_length)
    (if periodic then 1 else 0)
    alpha
    beta
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hann_window ~window_length ~options =
  let out__ = CArray.make t 1 in
  stubs_hann_window
    (CArray.start out__)
    (Int64.of_int window_length)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hann_window1 ~window_length ~periodic ~options =
  let out__ = CArray.make t 1 in
  stubs_hann_window1
    (CArray.start out__)
    (Int64.of_int window_length)
    (if periodic then 1 else 0)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hardshrink self =
  let out__ = CArray.make t 1 in
  stubs_hardshrink (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hardsigmoid self =
  let out__ = CArray.make t 1 in
  stubs_hardsigmoid (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hardsigmoid_ self =
  let out__ = CArray.make t 1 in
  stubs_hardsigmoid_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hardsigmoid_backward ~grad_output self =
  let out__ = CArray.make t 1 in
  stubs_hardsigmoid_backward (CArray.start out__) grad_output self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hardsigmoid_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_hardsigmoid_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hardswish self =
  let out__ = CArray.make t 1 in
  stubs_hardswish (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hardswish_ self =
  let out__ = CArray.make t 1 in
  stubs_hardswish_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hardswish_backward ~grad_output self =
  let out__ = CArray.make t 1 in
  stubs_hardswish_backward (CArray.start out__) grad_output self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hardswish_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_hardswish_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hardtanh self =
  let out__ = CArray.make t 1 in
  stubs_hardtanh (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hardtanh_ self =
  let out__ = CArray.make t 1 in
  stubs_hardtanh_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hardtanh_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_hardtanh_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let heaviside self ~values =
  let out__ = CArray.make t 1 in
  stubs_heaviside (CArray.start out__) self values;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let heaviside_ self ~values =
  let out__ = CArray.make t 1 in
  stubs_heaviside_ (CArray.start out__) self values;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let heaviside_out ~out self ~values =
  let out__ = CArray.make t 1 in
  stubs_heaviside_out (CArray.start out__) out self values;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hinge_embedding_loss self ~target ~margin ~reduction =
  let out__ = CArray.make t 1 in
  stubs_hinge_embedding_loss
    (CArray.start out__)
    self
    target
    margin
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let histc self ~bins =
  let out__ = CArray.make t 1 in
  stubs_histc (CArray.start out__) self (Int64.of_int bins);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let histc_out ~out self ~bins =
  let out__ = CArray.make t 1 in
  stubs_histc_out (CArray.start out__) out self (Int64.of_int bins);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hsplit self ~sections = stubs_hsplit self (Int64.of_int sections) |> to_tensor_list

let hsplit1 self ~indices =
  stubs_hsplit1
    self
    (List.map Int64.of_int indices |> CArray.of_list int64_t |> CArray.start)
    (List.length indices)
  |> to_tensor_list

let hspmm ~mat1 ~mat2 =
  let out__ = CArray.make t 1 in
  stubs_hspmm (CArray.start out__) mat1 mat2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hspmm_out ~out ~mat1 ~mat2 =
  let out__ = CArray.make t 1 in
  stubs_hspmm_out (CArray.start out__) out mat1 mat2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hstack tensors =
  let out__ = CArray.make t 1 in
  stubs_hstack
    (CArray.start out__)
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hstack_out ~out tensors =
  let out__ = CArray.make t 1 in
  stubs_hstack_out
    (CArray.start out__)
    out
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let huber_loss self ~target ~reduction ~delta =
  let out__ = CArray.make t 1 in
  stubs_huber_loss
    (CArray.start out__)
    self
    target
    (Reduction.to_int reduction |> Int64.of_int)
    delta;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let huber_loss_backward ~grad_output self ~target ~reduction ~delta =
  let out__ = CArray.make t 1 in
  stubs_huber_loss_backward
    (CArray.start out__)
    grad_output
    self
    target
    (Reduction.to_int reduction |> Int64.of_int)
    delta;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let huber_loss_backward_out ~grad_input ~grad_output self ~target ~reduction ~delta =
  let out__ = CArray.make t 1 in
  stubs_huber_loss_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    target
    (Reduction.to_int reduction |> Int64.of_int)
    delta;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let huber_loss_out ~out self ~target ~reduction ~delta =
  let out__ = CArray.make t 1 in
  stubs_huber_loss_out
    (CArray.start out__)
    out
    self
    target
    (Reduction.to_int reduction |> Int64.of_int)
    delta;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hypot self other =
  let out__ = CArray.make t 1 in
  stubs_hypot (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hypot_ self other =
  let out__ = CArray.make t 1 in
  stubs_hypot_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let hypot_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_hypot_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let i0 self =
  let out__ = CArray.make t 1 in
  stubs_i0 (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let i0_ self =
  let out__ = CArray.make t 1 in
  stubs_i0_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let i0_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_i0_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let igamma self other =
  let out__ = CArray.make t 1 in
  stubs_igamma (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let igamma_ self other =
  let out__ = CArray.make t 1 in
  stubs_igamma_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let igamma_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_igamma_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let igammac self other =
  let out__ = CArray.make t 1 in
  stubs_igammac (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let igammac_ self other =
  let out__ = CArray.make t 1 in
  stubs_igammac_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let igammac_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_igammac_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let im2col self ~kernel_size ~dilation ~padding ~stride =
  let out__ = CArray.make t 1 in
  stubs_im2col
    (CArray.start out__)
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let im2col_backward ~grad_output ~input_size ~kernel_size ~dilation ~padding ~stride =
  let out__ = CArray.make t 1 in
  stubs_im2col_backward
    (CArray.start out__)
    grad_output
    (List.map Int64.of_int input_size |> CArray.of_list int64_t |> CArray.start)
    (List.length input_size)
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let im2col_backward_out
    ~grad_input
    ~grad_output
    ~input_size
    ~kernel_size
    ~dilation
    ~padding
    ~stride
  =
  let out__ = CArray.make t 1 in
  stubs_im2col_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    (List.map Int64.of_int input_size |> CArray.of_list int64_t |> CArray.start)
    (List.length input_size)
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let im2col_out ~out self ~kernel_size ~dilation ~padding ~stride =
  let out__ = CArray.make t 1 in
  stubs_im2col_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let imag self =
  let out__ = CArray.make t 1 in
  stubs_imag (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let index self ~indices =
  let out__ = CArray.make t 1 in
  stubs_index
    (CArray.start out__)
    self
    (List.map
       (function
         | Some x -> x
         | None -> null)
       indices
    |> CArray.of_list t
    |> CArray.start)
    (List.length indices);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let index_add self ~dim ~index ~source =
  let out__ = CArray.make t 1 in
  stubs_index_add (CArray.start out__) self (Int64.of_int dim) index source;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let index_add_ self ~dim ~index ~source =
  let out__ = CArray.make t 1 in
  stubs_index_add_ (CArray.start out__) self (Int64.of_int dim) index source;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let index_copy self ~dim ~index ~source =
  let out__ = CArray.make t 1 in
  stubs_index_copy (CArray.start out__) self (Int64.of_int dim) index source;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let index_copy_ self ~dim ~index ~source =
  let out__ = CArray.make t 1 in
  stubs_index_copy_ (CArray.start out__) self (Int64.of_int dim) index source;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let index_fill self ~dim ~index ~value =
  let out__ = CArray.make t 1 in
  stubs_index_fill (CArray.start out__) self (Int64.of_int dim) index value;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let index_fill_ self ~dim ~index ~value =
  let out__ = CArray.make t 1 in
  stubs_index_fill_ (CArray.start out__) self (Int64.of_int dim) index value;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let index_put self ~indices ~values ~accumulate =
  let out__ = CArray.make t 1 in
  stubs_index_put
    (CArray.start out__)
    self
    (List.map
       (function
         | Some x -> x
         | None -> null)
       indices
    |> CArray.of_list t
    |> CArray.start)
    (List.length indices)
    values
    (if accumulate then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let index_put_ self ~indices ~values ~accumulate =
  let out__ = CArray.make t 1 in
  stubs_index_put_
    (CArray.start out__)
    self
    (List.map
       (function
         | Some x -> x
         | None -> null)
       indices
    |> CArray.of_list t
    |> CArray.start)
    (List.length indices)
    values
    (if accumulate then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let index_select self ~dim ~index =
  let out__ = CArray.make t 1 in
  stubs_index_select (CArray.start out__) self (Int64.of_int dim) index;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let index_select_backward ~grad ~self_sizes ~dim ~index =
  let out__ = CArray.make t 1 in
  stubs_index_select_backward
    (CArray.start out__)
    grad
    (List.map Int64.of_int self_sizes |> CArray.of_list int64_t |> CArray.start)
    (List.length self_sizes)
    (Int64.of_int dim)
    index;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let index_select_out ~out self ~dim ~index =
  let out__ = CArray.make t 1 in
  stubs_index_select_out (CArray.start out__) out self (Int64.of_int dim) index;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let indices self =
  let out__ = CArray.make t 1 in
  stubs_indices (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let infinitely_differentiable_gelu_backward ~grad self =
  let out__ = CArray.make t 1 in
  stubs_infinitely_differentiable_gelu_backward (CArray.start out__) grad self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let inner self other =
  let out__ = CArray.make t 1 in
  stubs_inner (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let inner_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_inner_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let instance_norm
    input
    ~weight
    ~bias
    ~running_mean
    ~running_var
    ~use_input_stats
    ~momentum
    ~eps
    ~cudnn_enabled
  =
  let out__ = CArray.make t 1 in
  stubs_instance_norm
    (CArray.start out__)
    input
    (match weight with
    | Some v -> v
    | None -> null)
    (match bias with
    | Some v -> v
    | None -> null)
    (match running_mean with
    | Some v -> v
    | None -> null)
    (match running_var with
    | Some v -> v
    | None -> null)
    (if use_input_stats then 1 else 0)
    momentum
    eps
    (if cudnn_enabled then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let int_repr self =
  let out__ = CArray.make t 1 in
  stubs_int_repr (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let inverse self =
  let out__ = CArray.make t 1 in
  stubs_inverse (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let inverse_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_inverse_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let isclose self other ~rtol ~atol ~equal_nan =
  let out__ = CArray.make t 1 in
  stubs_isclose (CArray.start out__) self other rtol atol (if equal_nan then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let isfinite self =
  let out__ = CArray.make t 1 in
  stubs_isfinite (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let isinf self =
  let out__ = CArray.make t 1 in
  stubs_isinf (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let isnan self =
  let out__ = CArray.make t 1 in
  stubs_isnan (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let isneginf self =
  let out__ = CArray.make t 1 in
  stubs_isneginf (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let isneginf_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_isneginf_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let isposinf self =
  let out__ = CArray.make t 1 in
  stubs_isposinf (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let isposinf_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_isposinf_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let isreal self =
  let out__ = CArray.make t 1 in
  stubs_isreal (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let istft
    self
    ~n_fft
    ~hop_length
    ~win_length
    ~window
    ~center
    ~normalized
    ~onesided
    ~length
    ~return_complex
  =
  let out__ = CArray.make t 1 in
  stubs_istft
    (CArray.start out__)
    self
    (Int64.of_int n_fft)
    (Int64.of_int hop_length)
    (Int64.of_int win_length)
    (match window with
    | Some v -> v
    | None -> null)
    (if center then 1 else 0)
    (if normalized then 1 else 0)
    (if onesided then 1 else 0)
    (Int64.of_int length)
    (if return_complex then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let kaiser_window ~window_length ~options =
  let out__ = CArray.make t 1 in
  stubs_kaiser_window
    (CArray.start out__)
    (Int64.of_int window_length)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let kaiser_window1 ~window_length ~periodic ~options =
  let out__ = CArray.make t 1 in
  stubs_kaiser_window1
    (CArray.start out__)
    (Int64.of_int window_length)
    (if periodic then 1 else 0)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let kaiser_window2 ~window_length ~periodic ~beta ~options =
  let out__ = CArray.make t 1 in
  stubs_kaiser_window2
    (CArray.start out__)
    (Int64.of_int window_length)
    (if periodic then 1 else 0)
    beta
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let kl_div self ~target ~reduction ~log_target =
  let out__ = CArray.make t 1 in
  stubs_kl_div
    (CArray.start out__)
    self
    target
    (Reduction.to_int reduction |> Int64.of_int)
    (if log_target then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let kl_div_backward ~grad_output self ~target ~reduction ~log_target =
  let out__ = CArray.make t 1 in
  stubs_kl_div_backward
    (CArray.start out__)
    grad_output
    self
    target
    (Reduction.to_int reduction |> Int64.of_int)
    (if log_target then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let kron self other =
  let out__ = CArray.make t 1 in
  stubs_kron (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let kron_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_kron_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let kthvalue self ~k ~dim ~keepdim =
  let out__ = CArray.make t 2 in
  stubs_kthvalue
    (CArray.start out__)
    self
    (Int64.of_int k)
    (Int64.of_int dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let kthvalue_out ~values ~indices self ~k ~dim ~keepdim =
  let out__ = CArray.make t 2 in
  stubs_kthvalue_out
    (CArray.start out__)
    values
    indices
    self
    (Int64.of_int k)
    (Int64.of_int dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let l1_loss self ~target ~reduction =
  let out__ = CArray.make t 1 in
  stubs_l1_loss
    (CArray.start out__)
    self
    target
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let l1_loss_backward ~grad_output self ~target ~reduction =
  let out__ = CArray.make t 1 in
  stubs_l1_loss_backward
    (CArray.start out__)
    grad_output
    self
    target
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let l1_loss_backward_out ~grad_input ~grad_output self ~target ~reduction =
  let out__ = CArray.make t 1 in
  stubs_l1_loss_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    target
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let l1_loss_out ~out self ~target ~reduction =
  let out__ = CArray.make t 1 in
  stubs_l1_loss_out
    (CArray.start out__)
    out
    self
    target
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let layer_norm input ~normalized_shape ~weight ~bias ~eps ~cudnn_enable =
  let out__ = CArray.make t 1 in
  stubs_layer_norm
    (CArray.start out__)
    input
    (List.map Int64.of_int normalized_shape |> CArray.of_list int64_t |> CArray.start)
    (List.length normalized_shape)
    (match weight with
    | Some v -> v
    | None -> null)
    (match bias with
    | Some v -> v
    | None -> null)
    eps
    (if cudnn_enable then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let lcm self other =
  let out__ = CArray.make t 1 in
  stubs_lcm (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let lcm_ self other =
  let out__ = CArray.make t 1 in
  stubs_lcm_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let lcm_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_lcm_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ldexp self other =
  let out__ = CArray.make t 1 in
  stubs_ldexp (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ldexp_ self other =
  let out__ = CArray.make t 1 in
  stubs_ldexp_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ldexp_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_ldexp_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let le self other =
  let out__ = CArray.make t 1 in
  stubs_le (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let le_ self other =
  let out__ = CArray.make t 1 in
  stubs_le_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let le_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_le_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let leaky_relu self =
  let out__ = CArray.make t 1 in
  stubs_leaky_relu (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let leaky_relu_ self =
  let out__ = CArray.make t 1 in
  stubs_leaky_relu_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let leaky_relu_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_leaky_relu_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let lerp self ~end_ ~weight =
  let out__ = CArray.make t 1 in
  stubs_lerp (CArray.start out__) self end_ weight;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let lerp_ self ~end_ ~weight =
  let out__ = CArray.make t 1 in
  stubs_lerp_ (CArray.start out__) self end_ weight;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let lerp_out ~out self ~end_ ~weight =
  let out__ = CArray.make t 1 in
  stubs_lerp_out (CArray.start out__) out self end_ weight;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let less self other =
  let out__ = CArray.make t 1 in
  stubs_less (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let less_ self other =
  let out__ = CArray.make t 1 in
  stubs_less_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let less_equal self other =
  let out__ = CArray.make t 1 in
  stubs_less_equal (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let less_equal_ self other =
  let out__ = CArray.make t 1 in
  stubs_less_equal_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let less_equal_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_less_equal_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let less_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_less_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let lgamma self =
  let out__ = CArray.make t 1 in
  stubs_lgamma (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let lgamma_ self =
  let out__ = CArray.make t 1 in
  stubs_lgamma_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let lgamma_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_lgamma_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_cholesky self =
  let out__ = CArray.make t 1 in
  stubs_linalg_cholesky (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_cholesky_ex self ~check_errors =
  let out__ = CArray.make t 2 in
  stubs_linalg_cholesky_ex (CArray.start out__) self (if check_errors then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let linalg_cholesky_ex_out ~l ~info self ~check_errors =
  let out__ = CArray.make t 2 in
  stubs_linalg_cholesky_ex_out
    (CArray.start out__)
    l
    info
    self
    (if check_errors then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let linalg_cholesky_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_linalg_cholesky_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_cond self =
  let out__ = CArray.make t 1 in
  stubs_linalg_cond (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_cond1 self ~p =
  let out__ = CArray.make t 1 in
  stubs_linalg_cond1 (CArray.start out__) self p;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_cond_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_linalg_cond_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_cond_out1 ~out self ~p =
  let out__ = CArray.make t 1 in
  stubs_linalg_cond_out1 (CArray.start out__) out self p;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_det self =
  let out__ = CArray.make t 1 in
  stubs_linalg_det (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_det_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_linalg_det_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_eig self =
  let out__ = CArray.make t 2 in
  stubs_linalg_eig (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let linalg_eig_out ~eigenvalues ~eigenvectors self =
  let out__ = CArray.make t 2 in
  stubs_linalg_eig_out (CArray.start out__) eigenvalues eigenvectors self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let linalg_eigh self ~uplo =
  let out__ = CArray.make t 2 in
  stubs_linalg_eigh (CArray.start out__) self uplo;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let linalg_eigh_out ~eigvals ~eigvecs self ~uplo =
  let out__ = CArray.make t 2 in
  stubs_linalg_eigh_out (CArray.start out__) eigvals eigvecs self uplo;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let linalg_eigvals self =
  let out__ = CArray.make t 1 in
  stubs_linalg_eigvals (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_eigvals_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_linalg_eigvals_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_eigvalsh self ~uplo =
  let out__ = CArray.make t 1 in
  stubs_linalg_eigvalsh (CArray.start out__) self uplo;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_eigvalsh_out ~out self ~uplo =
  let out__ = CArray.make t 1 in
  stubs_linalg_eigvalsh_out (CArray.start out__) out self uplo;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_householder_product input ~tau =
  let out__ = CArray.make t 1 in
  stubs_linalg_householder_product (CArray.start out__) input tau;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_householder_product_out ~out input ~tau =
  let out__ = CArray.make t 1 in
  stubs_linalg_householder_product_out (CArray.start out__) out input tau;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_inv self =
  let out__ = CArray.make t 1 in
  stubs_linalg_inv (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_inv_ex self ~check_errors =
  let out__ = CArray.make t 2 in
  stubs_linalg_inv_ex (CArray.start out__) self (if check_errors then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let linalg_inv_ex_out ~inverse ~info self ~check_errors =
  let out__ = CArray.make t 2 in
  stubs_linalg_inv_ex_out
    (CArray.start out__)
    inverse
    info
    self
    (if check_errors then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let linalg_inv_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_linalg_inv_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_lstsq self ~b ~rcond ~driver =
  let out__ = CArray.make t 4 in
  stubs_linalg_lstsq (CArray.start out__) self b rcond driver;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  let t3 = CArray.get out__ 3 in
  Gc.finalise C.Tensor.free t3;
  t0, t1, t2, t3

let linalg_lstsq_out ~solution ~residuals ~rank ~singular_values self ~b ~rcond ~driver =
  let out__ = CArray.make t 4 in
  stubs_linalg_lstsq_out
    (CArray.start out__)
    solution
    residuals
    rank
    singular_values
    self
    b
    rcond
    driver;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  let t3 = CArray.get out__ 3 in
  Gc.finalise C.Tensor.free t3;
  t0, t1, t2, t3

let linalg_matrix_norm self ~ord ~dim ~keepdim ~dtype =
  let out__ = CArray.make t 1 in
  stubs_linalg_matrix_norm
    (CArray.start out__)
    self
    ord
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if keepdim then 1 else 0)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_matrix_norm_out ~out self ~ord ~dim ~keepdim ~dtype =
  let out__ = CArray.make t 1 in
  stubs_linalg_matrix_norm_out
    (CArray.start out__)
    out
    self
    ord
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if keepdim then 1 else 0)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_matrix_power self ~n =
  let out__ = CArray.make t 1 in
  stubs_linalg_matrix_power (CArray.start out__) self (Int64.of_int n);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_matrix_power_out ~out self ~n =
  let out__ = CArray.make t 1 in
  stubs_linalg_matrix_power_out (CArray.start out__) out self (Int64.of_int n);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_matrix_rank self ~tol ~hermitian =
  let out__ = CArray.make t 1 in
  stubs_linalg_matrix_rank (CArray.start out__) self tol (if hermitian then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_matrix_rank1 input ~tol ~hermitian =
  let out__ = CArray.make t 1 in
  stubs_linalg_matrix_rank1 (CArray.start out__) input tol (if hermitian then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_matrix_rank_out ~out self ~tol ~hermitian =
  let out__ = CArray.make t 1 in
  stubs_linalg_matrix_rank_out
    (CArray.start out__)
    out
    self
    tol
    (if hermitian then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_matrix_rank_out1 ~out input ~tol ~hermitian =
  let out__ = CArray.make t 1 in
  stubs_linalg_matrix_rank_out1
    (CArray.start out__)
    out
    input
    tol
    (if hermitian then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_multi_dot tensors =
  let out__ = CArray.make t 1 in
  stubs_linalg_multi_dot
    (CArray.start out__)
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_multi_dot_out ~out tensors =
  let out__ = CArray.make t 1 in
  stubs_linalg_multi_dot_out
    (CArray.start out__)
    out
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_pinv self ~rcond ~hermitian =
  let out__ = CArray.make t 1 in
  stubs_linalg_pinv (CArray.start out__) self rcond (if hermitian then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_pinv1 self ~rcond ~hermitian =
  let out__ = CArray.make t 1 in
  stubs_linalg_pinv1 (CArray.start out__) self rcond (if hermitian then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_pinv_out ~out self ~rcond ~hermitian =
  let out__ = CArray.make t 1 in
  stubs_linalg_pinv_out (CArray.start out__) out self rcond (if hermitian then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_pinv_out1 ~out self ~rcond ~hermitian =
  let out__ = CArray.make t 1 in
  stubs_linalg_pinv_out1 (CArray.start out__) out self rcond (if hermitian then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_qr self ~mode =
  let out__ = CArray.make t 2 in
  stubs_linalg_qr (CArray.start out__) self mode;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let linalg_qr_out ~q ~r self ~mode =
  let out__ = CArray.make t 2 in
  stubs_linalg_qr_out (CArray.start out__) q r self mode;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let linalg_slogdet self =
  let out__ = CArray.make t 2 in
  stubs_linalg_slogdet (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let linalg_slogdet_out ~sign ~logabsdet self =
  let out__ = CArray.make t 2 in
  stubs_linalg_slogdet_out (CArray.start out__) sign logabsdet self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let linalg_solve input other =
  let out__ = CArray.make t 1 in
  stubs_linalg_solve (CArray.start out__) input other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_solve_out ~out input other =
  let out__ = CArray.make t 1 in
  stubs_linalg_solve_out (CArray.start out__) out input other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_svd self ~full_matrices =
  let out__ = CArray.make t 3 in
  stubs_linalg_svd (CArray.start out__) self (if full_matrices then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let linalg_svd_out ~u ~s ~vh self ~full_matrices =
  let out__ = CArray.make t 3 in
  stubs_linalg_svd_out (CArray.start out__) u s vh self (if full_matrices then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let linalg_svdvals input =
  let out__ = CArray.make t 1 in
  stubs_linalg_svdvals (CArray.start out__) input;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_svdvals_out ~out input =
  let out__ = CArray.make t 1 in
  stubs_linalg_svdvals_out (CArray.start out__) out input;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_tensorinv self ~ind =
  let out__ = CArray.make t 1 in
  stubs_linalg_tensorinv (CArray.start out__) self (Int64.of_int ind);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_tensorinv_out ~out self ~ind =
  let out__ = CArray.make t 1 in
  stubs_linalg_tensorinv_out (CArray.start out__) out self (Int64.of_int ind);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_tensorsolve self other ~dims =
  let out__ = CArray.make t 1 in
  stubs_linalg_tensorsolve
    (CArray.start out__)
    self
    other
    (List.map Int64.of_int dims |> CArray.of_list int64_t |> CArray.start)
    (List.length dims);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linalg_tensorsolve_out ~out self other ~dims =
  let out__ = CArray.make t 1 in
  stubs_linalg_tensorsolve_out
    (CArray.start out__)
    out
    self
    other
    (List.map Int64.of_int dims |> CArray.of_list int64_t |> CArray.start)
    (List.length dims);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let linear input ~weight ~bias =
  let out__ = CArray.make t 1 in
  stubs_linear
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let log self =
  let out__ = CArray.make t 1 in
  stubs_log (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let log10 self =
  let out__ = CArray.make t 1 in
  stubs_log10 (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let log10_ self =
  let out__ = CArray.make t 1 in
  stubs_log10_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let log10_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_log10_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let log1p self =
  let out__ = CArray.make t 1 in
  stubs_log1p (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let log1p_ self =
  let out__ = CArray.make t 1 in
  stubs_log1p_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let log1p_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_log1p_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let log2 self =
  let out__ = CArray.make t 1 in
  stubs_log2 (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let log2_ self =
  let out__ = CArray.make t 1 in
  stubs_log2_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let log2_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_log2_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let log_ self =
  let out__ = CArray.make t 1 in
  stubs_log_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let log_normal_ self ~mean ~std =
  let out__ = CArray.make t 1 in
  stubs_log_normal_ (CArray.start out__) self mean std;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let log_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_log_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let log_sigmoid self =
  let out__ = CArray.make t 1 in
  stubs_log_sigmoid (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let log_sigmoid_backward ~grad_output self ~buffer =
  let out__ = CArray.make t 1 in
  stubs_log_sigmoid_backward (CArray.start out__) grad_output self buffer;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let log_sigmoid_backward_out ~grad_input ~grad_output self ~buffer =
  let out__ = CArray.make t 1 in
  stubs_log_sigmoid_backward_out (CArray.start out__) grad_input grad_output self buffer;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let log_sigmoid_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_log_sigmoid_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let log_softmax self ~dim ~dtype =
  let out__ = CArray.make t 1 in
  stubs_log_softmax
    (CArray.start out__)
    self
    (Int64.of_int dim)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logaddexp self other =
  let out__ = CArray.make t 1 in
  stubs_logaddexp (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logaddexp2 self other =
  let out__ = CArray.make t 1 in
  stubs_logaddexp2 (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logaddexp2_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_logaddexp2_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logaddexp_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_logaddexp_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logcumsumexp self ~dim =
  let out__ = CArray.make t 1 in
  stubs_logcumsumexp (CArray.start out__) self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logcumsumexp_out ~out self ~dim =
  let out__ = CArray.make t 1 in
  stubs_logcumsumexp_out (CArray.start out__) out self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logdet self =
  let out__ = CArray.make t 1 in
  stubs_logdet (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logical_and self other =
  let out__ = CArray.make t 1 in
  stubs_logical_and (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logical_and_ self other =
  let out__ = CArray.make t 1 in
  stubs_logical_and_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logical_and_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_logical_and_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logical_not self =
  let out__ = CArray.make t 1 in
  stubs_logical_not (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logical_not_ self =
  let out__ = CArray.make t 1 in
  stubs_logical_not_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logical_not_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_logical_not_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logical_or self other =
  let out__ = CArray.make t 1 in
  stubs_logical_or (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logical_or_ self other =
  let out__ = CArray.make t 1 in
  stubs_logical_or_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logical_or_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_logical_or_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logical_xor self other =
  let out__ = CArray.make t 1 in
  stubs_logical_xor (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logical_xor_ self other =
  let out__ = CArray.make t 1 in
  stubs_logical_xor_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logical_xor_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_logical_xor_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logit self ~eps =
  let out__ = CArray.make t 1 in
  stubs_logit (CArray.start out__) self eps;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logit_ self ~eps =
  let out__ = CArray.make t 1 in
  stubs_logit_ (CArray.start out__) self eps;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logit_backward ~grad_output self ~eps =
  let out__ = CArray.make t 1 in
  stubs_logit_backward (CArray.start out__) grad_output self eps;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logit_backward_out ~grad_input ~grad_output self ~eps =
  let out__ = CArray.make t 1 in
  stubs_logit_backward_out (CArray.start out__) grad_input grad_output self eps;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logit_out ~out self ~eps =
  let out__ = CArray.make t 1 in
  stubs_logit_out (CArray.start out__) out self eps;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logsumexp self ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_logsumexp
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let logsumexp_out ~out self ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_logsumexp_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let lstm
    input
    ~hx
    ~params
    ~has_biases
    ~num_layers
    ~dropout
    ~train
    ~bidirectional
    ~batch_first
  =
  let out__ = CArray.make t 3 in
  stubs_lstm
    (CArray.start out__)
    input
    (CArray.of_list t hx |> CArray.start)
    (List.length hx)
    (CArray.of_list t params |> CArray.start)
    (List.length params)
    (if has_biases then 1 else 0)
    (Int64.of_int num_layers)
    dropout
    (if train then 1 else 0)
    (if bidirectional then 1 else 0)
    (if batch_first then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let lstm1
    ~data
    ~batch_sizes
    ~hx
    ~params
    ~has_biases
    ~num_layers
    ~dropout
    ~train
    ~bidirectional
  =
  let out__ = CArray.make t 3 in
  stubs_lstm1
    (CArray.start out__)
    data
    batch_sizes
    (CArray.of_list t hx |> CArray.start)
    (List.length hx)
    (CArray.of_list t params |> CArray.start)
    (List.length params)
    (if has_biases then 1 else 0)
    (Int64.of_int num_layers)
    dropout
    (if train then 1 else 0)
    (if bidirectional then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let lstm_cell input ~hx ~w_ih ~w_hh ~b_ih ~b_hh =
  let out__ = CArray.make t 2 in
  stubs_lstm_cell
    (CArray.start out__)
    input
    (CArray.of_list t hx |> CArray.start)
    (List.length hx)
    w_ih
    w_hh
    (match b_ih with
    | Some v -> v
    | None -> null)
    (match b_hh with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let lstsq self ~a =
  let out__ = CArray.make t 2 in
  stubs_lstsq (CArray.start out__) self a;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let lstsq_out ~x ~qr self ~a =
  let out__ = CArray.make t 2 in
  stubs_lstsq_out (CArray.start out__) x qr self a;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let lt self other =
  let out__ = CArray.make t 1 in
  stubs_lt (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let lt_ self other =
  let out__ = CArray.make t 1 in
  stubs_lt_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let lt_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_lt_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let lu_solve self ~lu_data ~lu_pivots =
  let out__ = CArray.make t 1 in
  stubs_lu_solve (CArray.start out__) self lu_data lu_pivots;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let lu_solve_out ~out self ~lu_data ~lu_pivots =
  let out__ = CArray.make t 1 in
  stubs_lu_solve_out (CArray.start out__) out self lu_data lu_pivots;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let lu_unpack ~lu_data ~lu_pivots ~unpack_data ~unpack_pivots =
  let out__ = CArray.make t 3 in
  stubs_lu_unpack
    (CArray.start out__)
    lu_data
    lu_pivots
    (if unpack_data then 1 else 0)
    (if unpack_pivots then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let lu_unpack_out ~p ~l ~u ~lu_data ~lu_pivots ~unpack_data ~unpack_pivots =
  let out__ = CArray.make t 3 in
  stubs_lu_unpack_out
    (CArray.start out__)
    p
    l
    u
    lu_data
    lu_pivots
    (if unpack_data then 1 else 0)
    (if unpack_pivots then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let margin_ranking_loss ~input1 ~input2 ~target ~margin ~reduction =
  let out__ = CArray.make t 1 in
  stubs_margin_ranking_loss
    (CArray.start out__)
    input1
    input2
    target
    margin
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let masked_fill self ~mask ~value =
  let out__ = CArray.make t 1 in
  stubs_masked_fill (CArray.start out__) self mask value;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let masked_fill_ self ~mask ~value =
  let out__ = CArray.make t 1 in
  stubs_masked_fill_ (CArray.start out__) self mask value;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let masked_scatter self ~mask ~source =
  let out__ = CArray.make t 1 in
  stubs_masked_scatter (CArray.start out__) self mask source;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let masked_scatter_ self ~mask ~source =
  let out__ = CArray.make t 1 in
  stubs_masked_scatter_ (CArray.start out__) self mask source;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let masked_select self ~mask =
  let out__ = CArray.make t 1 in
  stubs_masked_select (CArray.start out__) self mask;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let masked_select_backward ~grad input ~mask =
  let out__ = CArray.make t 1 in
  stubs_masked_select_backward (CArray.start out__) grad input mask;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let masked_select_out ~out self ~mask =
  let out__ = CArray.make t 1 in
  stubs_masked_select_out (CArray.start out__) out self mask;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let matmul self other =
  let out__ = CArray.make t 1 in
  stubs_matmul (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let matmul_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_matmul_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let matrix_exp self =
  let out__ = CArray.make t 1 in
  stubs_matrix_exp (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let matrix_exp_backward self ~grad =
  let out__ = CArray.make t 1 in
  stubs_matrix_exp_backward (CArray.start out__) self grad;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let matrix_power self ~n =
  let out__ = CArray.make t 1 in
  stubs_matrix_power (CArray.start out__) self (Int64.of_int n);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let matrix_power_out ~out self ~n =
  let out__ = CArray.make t 1 in
  stubs_matrix_power_out (CArray.start out__) out self (Int64.of_int n);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let matrix_rank self ~symmetric =
  let out__ = CArray.make t 1 in
  stubs_matrix_rank (CArray.start out__) self (if symmetric then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let matrix_rank1 self ~tol ~symmetric =
  let out__ = CArray.make t 1 in
  stubs_matrix_rank1 (CArray.start out__) self tol (if symmetric then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let max self =
  let out__ = CArray.make t 1 in
  stubs_max (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let max1 self other =
  let out__ = CArray.make t 1 in
  stubs_max1 (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let max2 self ~dim ~keepdim =
  let out__ = CArray.make t 2 in
  stubs_max2 (CArray.start out__) self (Int64.of_int dim) (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let max_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_max_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let max_out1 ~max ~max_values self ~dim ~keepdim =
  let out__ = CArray.make t 2 in
  stubs_max_out1
    (CArray.start out__)
    max
    max_values
    self
    (Int64.of_int dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let max_pool1d self ~kernel_size ~stride ~padding ~dilation ~ceil_mode =
  let out__ = CArray.make t 1 in
  stubs_max_pool1d
    (CArray.start out__)
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if ceil_mode then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let max_pool1d_with_indices self ~kernel_size ~stride ~padding ~dilation ~ceil_mode =
  let out__ = CArray.make t 2 in
  stubs_max_pool1d_with_indices
    (CArray.start out__)
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if ceil_mode then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let max_pool2d self ~kernel_size ~stride ~padding ~dilation ~ceil_mode =
  let out__ = CArray.make t 1 in
  stubs_max_pool2d
    (CArray.start out__)
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if ceil_mode then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let max_pool2d_with_indices self ~kernel_size ~stride ~padding ~dilation ~ceil_mode =
  let out__ = CArray.make t 2 in
  stubs_max_pool2d_with_indices
    (CArray.start out__)
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if ceil_mode then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let max_pool2d_with_indices_backward
    ~grad_output
    self
    ~kernel_size
    ~stride
    ~padding
    ~dilation
    ~ceil_mode
    ~indices
  =
  let out__ = CArray.make t 1 in
  stubs_max_pool2d_with_indices_backward
    (CArray.start out__)
    grad_output
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if ceil_mode then 1 else 0)
    indices;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let max_pool2d_with_indices_backward_out
    ~grad_input
    ~grad_output
    self
    ~kernel_size
    ~stride
    ~padding
    ~dilation
    ~ceil_mode
    ~indices
  =
  let out__ = CArray.make t 1 in
  stubs_max_pool2d_with_indices_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if ceil_mode then 1 else 0)
    indices;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let max_pool2d_with_indices_out
    ~out
    ~indices
    self
    ~kernel_size
    ~stride
    ~padding
    ~dilation
    ~ceil_mode
  =
  let out__ = CArray.make t 2 in
  stubs_max_pool2d_with_indices_out
    (CArray.start out__)
    out
    indices
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if ceil_mode then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let max_pool3d self ~kernel_size ~stride ~padding ~dilation ~ceil_mode =
  let out__ = CArray.make t 1 in
  stubs_max_pool3d
    (CArray.start out__)
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if ceil_mode then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let max_pool3d_with_indices self ~kernel_size ~stride ~padding ~dilation ~ceil_mode =
  let out__ = CArray.make t 2 in
  stubs_max_pool3d_with_indices
    (CArray.start out__)
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if ceil_mode then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let max_pool3d_with_indices_backward
    ~grad_output
    self
    ~kernel_size
    ~stride
    ~padding
    ~dilation
    ~ceil_mode
    ~indices
  =
  let out__ = CArray.make t 1 in
  stubs_max_pool3d_with_indices_backward
    (CArray.start out__)
    grad_output
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if ceil_mode then 1 else 0)
    indices;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let max_pool3d_with_indices_backward_out
    ~grad_input
    ~grad_output
    self
    ~kernel_size
    ~stride
    ~padding
    ~dilation
    ~ceil_mode
    ~indices
  =
  let out__ = CArray.make t 1 in
  stubs_max_pool3d_with_indices_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if ceil_mode then 1 else 0)
    indices;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let max_pool3d_with_indices_out
    ~out
    ~indices
    self
    ~kernel_size
    ~stride
    ~padding
    ~dilation
    ~ceil_mode
  =
  let out__ = CArray.make t 2 in
  stubs_max_pool3d_with_indices_out
    (CArray.start out__)
    out
    indices
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if ceil_mode then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let max_unpool2d self ~indices ~output_size =
  let out__ = CArray.make t 1 in
  stubs_max_unpool2d
    (CArray.start out__)
    self
    indices
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let max_unpool2d_backward ~grad_output self ~indices ~output_size =
  let out__ = CArray.make t 1 in
  stubs_max_unpool2d_backward
    (CArray.start out__)
    grad_output
    self
    indices
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let max_unpool2d_backward_out ~grad_input ~grad_output self ~indices ~output_size =
  let out__ = CArray.make t 1 in
  stubs_max_unpool2d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    indices
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let max_unpool2d_out ~out self ~indices ~output_size =
  let out__ = CArray.make t 1 in
  stubs_max_unpool2d_out
    (CArray.start out__)
    out
    self
    indices
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let max_unpool3d self ~indices ~output_size ~stride ~padding =
  let out__ = CArray.make t 1 in
  stubs_max_unpool3d
    (CArray.start out__)
    self
    indices
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let max_unpool3d_backward ~grad_output self ~indices ~output_size ~stride ~padding =
  let out__ = CArray.make t 1 in
  stubs_max_unpool3d_backward
    (CArray.start out__)
    grad_output
    self
    indices
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let max_unpool3d_backward_out
    ~grad_input
    ~grad_output
    self
    ~indices
    ~output_size
    ~stride
    ~padding
  =
  let out__ = CArray.make t 1 in
  stubs_max_unpool3d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    indices
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let max_unpool3d_out ~out self ~indices ~output_size ~stride ~padding =
  let out__ = CArray.make t 1 in
  stubs_max_unpool3d_out
    (CArray.start out__)
    out
    self
    indices
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let maximum self other =
  let out__ = CArray.make t 1 in
  stubs_maximum (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let maximum_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_maximum_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mean self ~dtype =
  let out__ = CArray.make t 1 in
  stubs_mean (CArray.start out__) self (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mean1 self ~dim ~keepdim ~dtype =
  let out__ = CArray.make t 1 in
  stubs_mean1
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if keepdim then 1 else 0)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mean_out ~out self ~dim ~keepdim ~dtype =
  let out__ = CArray.make t 1 in
  stubs_mean_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if keepdim then 1 else 0)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let median self =
  let out__ = CArray.make t 1 in
  stubs_median (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let median1 self ~dim ~keepdim =
  let out__ = CArray.make t 2 in
  stubs_median1 (CArray.start out__) self (Int64.of_int dim) (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let median_out ~values ~indices self ~dim ~keepdim =
  let out__ = CArray.make t 2 in
  stubs_median_out
    (CArray.start out__)
    values
    indices
    self
    (Int64.of_int dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let meshgrid tensors =
  stubs_meshgrid (CArray.of_list t tensors |> CArray.start) (List.length tensors)
  |> to_tensor_list

let min self =
  let out__ = CArray.make t 1 in
  stubs_min (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let min1 self other =
  let out__ = CArray.make t 1 in
  stubs_min1 (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let min2 self ~dim ~keepdim =
  let out__ = CArray.make t 2 in
  stubs_min2 (CArray.start out__) self (Int64.of_int dim) (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let min_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_min_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let min_out1 ~min ~min_indices self ~dim ~keepdim =
  let out__ = CArray.make t 2 in
  stubs_min_out1
    (CArray.start out__)
    min
    min_indices
    self
    (Int64.of_int dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let minimum self other =
  let out__ = CArray.make t 1 in
  stubs_minimum (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let minimum_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_minimum_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let miopen_batch_norm
    input
    ~weight
    ~bias
    ~running_mean
    ~running_var
    ~training
    ~exponential_average_factor
    ~epsilon
  =
  let out__ = CArray.make t 3 in
  stubs_miopen_batch_norm
    (CArray.start out__)
    input
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (match running_mean with
    | Some v -> v
    | None -> null)
    (match running_var with
    | Some v -> v
    | None -> null)
    (if training then 1 else 0)
    exponential_average_factor
    epsilon;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let miopen_batch_norm_backward
    input
    ~grad_output
    ~weight
    ~running_mean
    ~running_var
    ~save_mean
    ~save_var
    ~epsilon
  =
  let out__ = CArray.make t 3 in
  stubs_miopen_batch_norm_backward
    (CArray.start out__)
    input
    grad_output
    weight
    (match running_mean with
    | Some v -> v
    | None -> null)
    (match running_var with
    | Some v -> v
    | None -> null)
    (match save_mean with
    | Some v -> v
    | None -> null)
    (match save_var with
    | Some v -> v
    | None -> null)
    epsilon;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let miopen_convolution
    self
    ~weight
    ~bias
    ~padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
  =
  let out__ = CArray.make t 1 in
  stubs_miopen_convolution
    (CArray.start out__)
    self
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let miopen_convolution_backward_bias ~grad_output =
  let out__ = CArray.make t 1 in
  stubs_miopen_convolution_backward_bias (CArray.start out__) grad_output;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let miopen_convolution_backward_input
    ~self_size
    ~grad_output
    ~weight
    ~padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
  =
  let out__ = CArray.make t 1 in
  stubs_miopen_convolution_backward_input
    (CArray.start out__)
    (List.map Int64.of_int self_size |> CArray.of_list int64_t |> CArray.start)
    (List.length self_size)
    grad_output
    weight
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let miopen_convolution_backward_weight
    ~weight_size
    ~grad_output
    self
    ~padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
  =
  let out__ = CArray.make t 1 in
  stubs_miopen_convolution_backward_weight
    (CArray.start out__)
    (List.map Int64.of_int weight_size |> CArray.of_list int64_t |> CArray.start)
    (List.length weight_size)
    grad_output
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let miopen_convolution_transpose
    self
    ~weight
    ~bias
    ~padding
    ~output_padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
  =
  let out__ = CArray.make t 1 in
  stubs_miopen_convolution_transpose
    (CArray.start out__)
    self
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int output_padding |> CArray.of_list int64_t |> CArray.start)
    (List.length output_padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let miopen_convolution_transpose_backward_input
    ~grad_output
    ~weight
    ~padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
  =
  let out__ = CArray.make t 1 in
  stubs_miopen_convolution_transpose_backward_input
    (CArray.start out__)
    grad_output
    weight
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let miopen_convolution_transpose_backward_weight
    ~weight_size
    ~grad_output
    self
    ~padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
  =
  let out__ = CArray.make t 1 in
  stubs_miopen_convolution_transpose_backward_weight
    (CArray.start out__)
    (List.map Int64.of_int weight_size |> CArray.of_list int64_t |> CArray.start)
    (List.length weight_size)
    grad_output
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let miopen_depthwise_convolution
    self
    ~weight
    ~bias
    ~padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
  =
  let out__ = CArray.make t 1 in
  stubs_miopen_depthwise_convolution
    (CArray.start out__)
    self
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let miopen_depthwise_convolution_backward_input
    ~self_size
    ~grad_output
    ~weight
    ~padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
  =
  let out__ = CArray.make t 1 in
  stubs_miopen_depthwise_convolution_backward_input
    (CArray.start out__)
    (List.map Int64.of_int self_size |> CArray.of_list int64_t |> CArray.start)
    (List.length self_size)
    grad_output
    weight
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let miopen_depthwise_convolution_backward_weight
    ~weight_size
    ~grad_output
    self
    ~padding
    ~stride
    ~dilation
    ~groups
    ~benchmark
    ~deterministic
  =
  let out__ = CArray.make t 1 in
  stubs_miopen_depthwise_convolution_backward_weight
    (CArray.start out__)
    (List.map Int64.of_int weight_size |> CArray.of_list int64_t |> CArray.start)
    (List.length weight_size)
    grad_output
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if benchmark then 1 else 0)
    (if deterministic then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let miopen_rnn
    input
    ~weight
    ~weight_stride0
    ~hx
    ~cx
    ~mode
    ~hidden_size
    ~num_layers
    ~batch_first
    ~dropout
    ~train
    ~bidirectional
    ~batch_sizes
    ~dropout_state
  =
  let out__ = CArray.make t 5 in
  stubs_miopen_rnn
    (CArray.start out__)
    input
    (CArray.of_list t weight |> CArray.start)
    (List.length weight)
    (Int64.of_int weight_stride0)
    hx
    (match cx with
    | Some v -> v
    | None -> null)
    (Int64.of_int mode)
    (Int64.of_int hidden_size)
    (Int64.of_int num_layers)
    (if batch_first then 1 else 0)
    dropout
    (if train then 1 else 0)
    (if bidirectional then 1 else 0)
    (List.map Int64.of_int batch_sizes |> CArray.of_list int64_t |> CArray.start)
    (List.length batch_sizes)
    (match dropout_state with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  let t3 = CArray.get out__ 3 in
  Gc.finalise C.Tensor.free t3;
  let t4 = CArray.get out__ 4 in
  Gc.finalise C.Tensor.free t4;
  t0, t1, t2, t3, t4

let mish self =
  let out__ = CArray.make t 1 in
  stubs_mish (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mish_ self =
  let out__ = CArray.make t 1 in
  stubs_mish_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mish_backward ~grad_output self =
  let out__ = CArray.make t 1 in
  stubs_mish_backward (CArray.start out__) grad_output self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mish_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_mish_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mkldnn_adaptive_avg_pool2d self ~output_size =
  let out__ = CArray.make t 1 in
  stubs_mkldnn_adaptive_avg_pool2d
    (CArray.start out__)
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mkldnn_adaptive_avg_pool2d_backward ~grad_output self =
  let out__ = CArray.make t 1 in
  stubs_mkldnn_adaptive_avg_pool2d_backward (CArray.start out__) grad_output self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mkldnn_convolution self ~weight ~bias ~padding ~stride ~dilation ~groups =
  let out__ = CArray.make t 1 in
  stubs_mkldnn_convolution
    (CArray.start out__)
    self
    weight
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mkldnn_convolution_backward_input
    ~self_size
    ~grad_output
    ~weight
    ~padding
    ~stride
    ~dilation
    ~groups
    ~bias_defined
  =
  let out__ = CArray.make t 1 in
  stubs_mkldnn_convolution_backward_input
    (CArray.start out__)
    (List.map Int64.of_int self_size |> CArray.of_list int64_t |> CArray.start)
    (List.length self_size)
    grad_output
    weight
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if bias_defined then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mkldnn_convolution_backward_weights
    ~weight_size
    ~grad_output
    self
    ~padding
    ~stride
    ~dilation
    ~groups
    ~bias_defined
  =
  let out__ = CArray.make t 2 in
  stubs_mkldnn_convolution_backward_weights
    (CArray.start out__)
    (List.map Int64.of_int weight_size |> CArray.of_list int64_t |> CArray.start)
    (List.length weight_size)
    grad_output
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups)
    (if bias_defined then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let mkldnn_linear self ~weight ~bias =
  let out__ = CArray.make t 1 in
  stubs_mkldnn_linear
    (CArray.start out__)
    self
    weight
    (match bias with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mkldnn_linear_backward_input ~input_size ~grad_output ~weight =
  let out__ = CArray.make t 1 in
  stubs_mkldnn_linear_backward_input
    (CArray.start out__)
    (List.map Int64.of_int input_size |> CArray.of_list int64_t |> CArray.start)
    (List.length input_size)
    grad_output
    weight;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mkldnn_linear_backward_weights ~grad_output input ~weight ~bias_defined =
  let out__ = CArray.make t 2 in
  stubs_mkldnn_linear_backward_weights
    (CArray.start out__)
    grad_output
    input
    weight
    (if bias_defined then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let mkldnn_max_pool2d self ~kernel_size ~stride ~padding ~dilation ~ceil_mode =
  let out__ = CArray.make t 1 in
  stubs_mkldnn_max_pool2d
    (CArray.start out__)
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if ceil_mode then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mkldnn_max_pool2d_backward
    ~grad_output
    ~output
    input
    ~kernel_size
    ~stride
    ~padding
    ~dilation
    ~ceil_mode
  =
  let out__ = CArray.make t 1 in
  stubs_mkldnn_max_pool2d_backward
    (CArray.start out__)
    grad_output
    output
    input
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if ceil_mode then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mkldnn_max_pool3d self ~kernel_size ~stride ~padding ~dilation ~ceil_mode =
  let out__ = CArray.make t 1 in
  stubs_mkldnn_max_pool3d
    (CArray.start out__)
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if ceil_mode then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mkldnn_max_pool3d_backward
    ~grad_output
    ~output
    input
    ~kernel_size
    ~stride
    ~padding
    ~dilation
    ~ceil_mode
  =
  let out__ = CArray.make t 1 in
  stubs_mkldnn_max_pool3d_backward
    (CArray.start out__)
    grad_output
    output
    input
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if ceil_mode then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mkldnn_reorder_conv2d_weight self ~padding ~stride ~dilation ~groups =
  let out__ = CArray.make t 1 in
  stubs_mkldnn_reorder_conv2d_weight
    (CArray.start out__)
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mkldnn_reorder_conv3d_weight self ~padding ~stride ~dilation ~groups =
  let out__ = CArray.make t 1 in
  stubs_mkldnn_reorder_conv3d_weight
    (CArray.start out__)
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (Int64.of_int groups);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mm self ~mat2 =
  let out__ = CArray.make t 1 in
  stubs_mm (CArray.start out__) self mat2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mm_out ~out self ~mat2 =
  let out__ = CArray.make t 1 in
  stubs_mm_out (CArray.start out__) out self mat2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mode self ~dim ~keepdim =
  let out__ = CArray.make t 2 in
  stubs_mode (CArray.start out__) self (Int64.of_int dim) (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let mode_out ~values ~indices self ~dim ~keepdim =
  let out__ = CArray.make t 2 in
  stubs_mode_out
    (CArray.start out__)
    values
    indices
    self
    (Int64.of_int dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let moveaxis self ~source ~destination =
  let out__ = CArray.make t 1 in
  stubs_moveaxis
    (CArray.start out__)
    self
    (List.map Int64.of_int source |> CArray.of_list int64_t |> CArray.start)
    (List.length source)
    (List.map Int64.of_int destination |> CArray.of_list int64_t |> CArray.start)
    (List.length destination);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let moveaxis1 self ~source ~destination =
  let out__ = CArray.make t 1 in
  stubs_moveaxis1
    (CArray.start out__)
    self
    (Int64.of_int source)
    (Int64.of_int destination);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let movedim self ~source ~destination =
  let out__ = CArray.make t 1 in
  stubs_movedim
    (CArray.start out__)
    self
    (List.map Int64.of_int source |> CArray.of_list int64_t |> CArray.start)
    (List.length source)
    (List.map Int64.of_int destination |> CArray.of_list int64_t |> CArray.start)
    (List.length destination);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let movedim1 self ~source ~destination =
  let out__ = CArray.make t 1 in
  stubs_movedim1
    (CArray.start out__)
    self
    (Int64.of_int source)
    (Int64.of_int destination);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mse_loss self ~target ~reduction =
  let out__ = CArray.make t 1 in
  stubs_mse_loss
    (CArray.start out__)
    self
    target
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mse_loss_backward ~grad_output self ~target ~reduction =
  let out__ = CArray.make t 1 in
  stubs_mse_loss_backward
    (CArray.start out__)
    grad_output
    self
    target
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mse_loss_backward_out ~grad_input ~grad_output self ~target ~reduction =
  let out__ = CArray.make t 1 in
  stubs_mse_loss_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    target
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mse_loss_out ~out self ~target ~reduction =
  let out__ = CArray.make t 1 in
  stubs_mse_loss_out
    (CArray.start out__)
    out
    self
    target
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let msort self =
  let out__ = CArray.make t 1 in
  stubs_msort (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let msort_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_msort_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mul self other =
  let out__ = CArray.make t 1 in
  stubs_mul (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mul_ self other =
  let out__ = CArray.make t 1 in
  stubs_mul_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mul_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_mul_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let multilabel_margin_loss self ~target ~reduction =
  let out__ = CArray.make t 1 in
  stubs_multilabel_margin_loss
    (CArray.start out__)
    self
    target
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let multilabel_margin_loss_backward ~grad_output self ~target ~reduction ~is_target =
  let out__ = CArray.make t 1 in
  stubs_multilabel_margin_loss_backward
    (CArray.start out__)
    grad_output
    self
    target
    (Reduction.to_int reduction |> Int64.of_int)
    is_target;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let multilabel_margin_loss_backward_out
    ~grad_input
    ~grad_output
    self
    ~target
    ~reduction
    ~is_target
  =
  let out__ = CArray.make t 1 in
  stubs_multilabel_margin_loss_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    target
    (Reduction.to_int reduction |> Int64.of_int)
    is_target;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let multilabel_margin_loss_out ~out self ~target ~reduction =
  let out__ = CArray.make t 1 in
  stubs_multilabel_margin_loss_out
    (CArray.start out__)
    out
    self
    target
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let multinomial self ~num_samples ~replacement =
  let out__ = CArray.make t 1 in
  stubs_multinomial
    (CArray.start out__)
    self
    (Int64.of_int num_samples)
    (if replacement then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let multinomial_out ~out self ~num_samples ~replacement =
  let out__ = CArray.make t 1 in
  stubs_multinomial_out
    (CArray.start out__)
    out
    self
    (Int64.of_int num_samples)
    (if replacement then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let multiply self other =
  let out__ = CArray.make t 1 in
  stubs_multiply (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let multiply_ self other =
  let out__ = CArray.make t 1 in
  stubs_multiply_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let multiply_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_multiply_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mv self ~vec =
  let out__ = CArray.make t 1 in
  stubs_mv (CArray.start out__) self vec;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mv_out ~out self ~vec =
  let out__ = CArray.make t 1 in
  stubs_mv_out (CArray.start out__) out self vec;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mvlgamma self ~p =
  let out__ = CArray.make t 1 in
  stubs_mvlgamma (CArray.start out__) self (Int64.of_int p);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let mvlgamma_ self ~p =
  let out__ = CArray.make t 1 in
  stubs_mvlgamma_ (CArray.start out__) self (Int64.of_int p);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nan_to_num self ~nan ~posinf ~neginf =
  let out__ = CArray.make t 1 in
  stubs_nan_to_num (CArray.start out__) self nan posinf neginf;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nan_to_num_ self ~nan ~posinf ~neginf =
  let out__ = CArray.make t 1 in
  stubs_nan_to_num_ (CArray.start out__) self nan posinf neginf;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nan_to_num_out ~out self ~nan ~posinf ~neginf =
  let out__ = CArray.make t 1 in
  stubs_nan_to_num_out (CArray.start out__) out self nan posinf neginf;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nanmedian self =
  let out__ = CArray.make t 1 in
  stubs_nanmedian (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nanmedian1 self ~dim ~keepdim =
  let out__ = CArray.make t 2 in
  stubs_nanmedian1 (CArray.start out__) self (Int64.of_int dim) (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let nanmedian_out ~values ~indices self ~dim ~keepdim =
  let out__ = CArray.make t 2 in
  stubs_nanmedian_out
    (CArray.start out__)
    values
    indices
    self
    (Int64.of_int dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let nanquantile self ~q ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_nanquantile
    (CArray.start out__)
    self
    q
    (Int64.of_int dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nanquantile1 self ~q ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_nanquantile1
    (CArray.start out__)
    self
    q
    (Int64.of_int dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nanquantile2 self ~q ~dim ~keepdim ~interpolation =
  let out__ = CArray.make t 1 in
  stubs_nanquantile2
    (CArray.start out__)
    self
    q
    (Int64.of_int dim)
    (if keepdim then 1 else 0)
    interpolation;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nanquantile3 self ~q ~dim ~keepdim ~interpolation =
  let out__ = CArray.make t 1 in
  stubs_nanquantile3
    (CArray.start out__)
    self
    q
    (Int64.of_int dim)
    (if keepdim then 1 else 0)
    interpolation;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nanquantile_out ~out self ~q ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_nanquantile_out
    (CArray.start out__)
    out
    self
    q
    (Int64.of_int dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nanquantile_out1 ~out self ~q ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_nanquantile_out1
    (CArray.start out__)
    out
    self
    q
    (Int64.of_int dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nanquantile_out2 ~out self ~q ~dim ~keepdim ~interpolation =
  let out__ = CArray.make t 1 in
  stubs_nanquantile_out2
    (CArray.start out__)
    out
    self
    q
    (Int64.of_int dim)
    (if keepdim then 1 else 0)
    interpolation;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nanquantile_out3 ~out self ~q ~dim ~keepdim ~interpolation =
  let out__ = CArray.make t 1 in
  stubs_nanquantile_out3
    (CArray.start out__)
    out
    self
    q
    (Int64.of_int dim)
    (if keepdim then 1 else 0)
    interpolation;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nansum self ~dtype =
  let out__ = CArray.make t 1 in
  stubs_nansum (CArray.start out__) self (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nansum1 self ~dim ~keepdim ~dtype =
  let out__ = CArray.make t 1 in
  stubs_nansum1
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if keepdim then 1 else 0)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nansum_out ~out self ~dim ~keepdim ~dtype =
  let out__ = CArray.make t 1 in
  stubs_nansum_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if keepdim then 1 else 0)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let narrow self ~dim ~start ~length =
  let out__ = CArray.make t 1 in
  stubs_narrow
    (CArray.start out__)
    self
    (Int64.of_int dim)
    (Int64.of_int start)
    (Int64.of_int length);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let narrow1 self ~dim ~start ~length =
  let out__ = CArray.make t 1 in
  stubs_narrow1 (CArray.start out__) self (Int64.of_int dim) start (Int64.of_int length);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let narrow_copy self ~dim ~start ~length =
  let out__ = CArray.make t 1 in
  stubs_narrow_copy
    (CArray.start out__)
    self
    (Int64.of_int dim)
    (Int64.of_int start)
    (Int64.of_int length);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let narrow_copy_out ~out self ~dim ~start ~length =
  let out__ = CArray.make t 1 in
  stubs_narrow_copy_out
    (CArray.start out__)
    out
    self
    (Int64.of_int dim)
    (Int64.of_int start)
    (Int64.of_int length);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let native_batch_norm
    input
    ~weight
    ~bias
    ~running_mean
    ~running_var
    ~training
    ~momentum
    ~eps
  =
  let out__ = CArray.make t 3 in
  stubs_native_batch_norm
    (CArray.start out__)
    input
    (match weight with
    | Some v -> v
    | None -> null)
    (match bias with
    | Some v -> v
    | None -> null)
    (match running_mean with
    | Some v -> v
    | None -> null)
    (match running_var with
    | Some v -> v
    | None -> null)
    (if training then 1 else 0)
    momentum
    eps;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let native_batch_norm_out
    ~out
    ~save_mean
    ~save_invstd
    input
    ~weight
    ~bias
    ~running_mean
    ~running_var
    ~training
    ~momentum
    ~eps
  =
  let out__ = CArray.make t 3 in
  stubs_native_batch_norm_out
    (CArray.start out__)
    out
    save_mean
    save_invstd
    input
    (match weight with
    | Some v -> v
    | None -> null)
    (match bias with
    | Some v -> v
    | None -> null)
    (match running_mean with
    | Some v -> v
    | None -> null)
    (match running_var with
    | Some v -> v
    | None -> null)
    (if training then 1 else 0)
    momentum
    eps;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let native_group_norm input ~weight ~bias ~n ~c ~hxw ~group ~eps =
  let out__ = CArray.make t 3 in
  stubs_native_group_norm
    (CArray.start out__)
    input
    (match weight with
    | Some v -> v
    | None -> null)
    (match bias with
    | Some v -> v
    | None -> null)
    (Int64.of_int n)
    (Int64.of_int c)
    (Int64.of_int hxw)
    (Int64.of_int group)
    eps;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let native_layer_norm input ~normalized_shape ~weight ~bias ~eps =
  let out__ = CArray.make t 3 in
  stubs_native_layer_norm
    (CArray.start out__)
    input
    (List.map Int64.of_int normalized_shape |> CArray.of_list int64_t |> CArray.start)
    (List.length normalized_shape)
    (match weight with
    | Some v -> v
    | None -> null)
    (match bias with
    | Some v -> v
    | None -> null)
    eps;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let native_norm self =
  let out__ = CArray.make t 1 in
  stubs_native_norm (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ne self other =
  let out__ = CArray.make t 1 in
  stubs_ne (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ne_ self other =
  let out__ = CArray.make t 1 in
  stubs_ne_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ne_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_ne_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let neg self =
  let out__ = CArray.make t 1 in
  stubs_neg (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let neg_ self =
  let out__ = CArray.make t 1 in
  stubs_neg_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let neg_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_neg_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let negative self =
  let out__ = CArray.make t 1 in
  stubs_negative (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let negative_ self =
  let out__ = CArray.make t 1 in
  stubs_negative_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let negative_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_negative_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let new_empty self ~size ~options =
  let out__ = CArray.make t 1 in
  stubs_new_empty
    (CArray.start out__)
    self
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let new_empty_strided self ~size ~stride ~options =
  let out__ = CArray.make t 1 in
  stubs_new_empty_strided
    (CArray.start out__)
    self
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let new_zeros self ~size ~options =
  let out__ = CArray.make t 1 in
  stubs_new_zeros
    (CArray.start out__)
    self
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nextafter self other =
  let out__ = CArray.make t 1 in
  stubs_nextafter (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nextafter_ self other =
  let out__ = CArray.make t 1 in
  stubs_nextafter_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nextafter_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_nextafter_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nll_loss self ~target ~weight ~reduction ~ignore_index =
  let out__ = CArray.make t 1 in
  stubs_nll_loss
    (CArray.start out__)
    self
    target
    (match weight with
    | Some v -> v
    | None -> null)
    (Reduction.to_int reduction |> Int64.of_int)
    (Int64.of_int ignore_index);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nll_loss2d self ~target ~weight ~reduction ~ignore_index =
  let out__ = CArray.make t 1 in
  stubs_nll_loss2d
    (CArray.start out__)
    self
    target
    (match weight with
    | Some v -> v
    | None -> null)
    (Reduction.to_int reduction |> Int64.of_int)
    (Int64.of_int ignore_index);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nll_loss2d_backward
    ~grad_output
    self
    ~target
    ~weight
    ~reduction
    ~ignore_index
    ~total_weight
  =
  let out__ = CArray.make t 1 in
  stubs_nll_loss2d_backward
    (CArray.start out__)
    grad_output
    self
    target
    (match weight with
    | Some v -> v
    | None -> null)
    (Reduction.to_int reduction |> Int64.of_int)
    (Int64.of_int ignore_index)
    total_weight;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nll_loss2d_backward_out
    ~grad_input
    ~grad_output
    self
    ~target
    ~weight
    ~reduction
    ~ignore_index
    ~total_weight
  =
  let out__ = CArray.make t 1 in
  stubs_nll_loss2d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    target
    (match weight with
    | Some v -> v
    | None -> null)
    (Reduction.to_int reduction |> Int64.of_int)
    (Int64.of_int ignore_index)
    total_weight;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nll_loss2d_out ~out self ~target ~weight ~reduction ~ignore_index =
  let out__ = CArray.make t 1 in
  stubs_nll_loss2d_out
    (CArray.start out__)
    out
    self
    target
    (match weight with
    | Some v -> v
    | None -> null)
    (Reduction.to_int reduction |> Int64.of_int)
    (Int64.of_int ignore_index);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nll_loss_backward
    ~grad_output
    self
    ~target
    ~weight
    ~reduction
    ~ignore_index
    ~total_weight
  =
  let out__ = CArray.make t 1 in
  stubs_nll_loss_backward
    (CArray.start out__)
    grad_output
    self
    target
    (match weight with
    | Some v -> v
    | None -> null)
    (Reduction.to_int reduction |> Int64.of_int)
    (Int64.of_int ignore_index)
    total_weight;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nll_loss_backward_out
    ~grad_input
    ~grad_output
    self
    ~target
    ~weight
    ~reduction
    ~ignore_index
    ~total_weight
  =
  let out__ = CArray.make t 1 in
  stubs_nll_loss_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    target
    (match weight with
    | Some v -> v
    | None -> null)
    (Reduction.to_int reduction |> Int64.of_int)
    (Int64.of_int ignore_index)
    total_weight;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nll_loss_nd self ~target ~weight ~reduction ~ignore_index =
  let out__ = CArray.make t 1 in
  stubs_nll_loss_nd
    (CArray.start out__)
    self
    target
    (match weight with
    | Some v -> v
    | None -> null)
    (Reduction.to_int reduction |> Int64.of_int)
    (Int64.of_int ignore_index);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nll_loss_out ~out self ~target ~weight ~reduction ~ignore_index =
  let out__ = CArray.make t 1 in
  stubs_nll_loss_out
    (CArray.start out__)
    out
    self
    target
    (match weight with
    | Some v -> v
    | None -> null)
    (Reduction.to_int reduction |> Int64.of_int)
    (Int64.of_int ignore_index);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nonzero self =
  let out__ = CArray.make t 1 in
  stubs_nonzero (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nonzero_numpy self = stubs_nonzero_numpy self |> to_tensor_list

let nonzero_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_nonzero_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let norm self =
  let out__ = CArray.make t 1 in
  stubs_norm (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let norm_except_dim ~v ~pow ~dim =
  let out__ = CArray.make t 1 in
  stubs_norm_except_dim (CArray.start out__) v (Int64.of_int pow) (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let normal_ self ~mean ~std =
  let out__ = CArray.make t 1 in
  stubs_normal_ (CArray.start out__) self mean std;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let normal_out ~out ~mean ~std =
  let out__ = CArray.make t 1 in
  stubs_normal_out (CArray.start out__) out mean std;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let normal_out1 ~out ~mean ~std =
  let out__ = CArray.make t 1 in
  stubs_normal_out1 (CArray.start out__) out mean std;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let normal_out2 ~out ~mean ~std =
  let out__ = CArray.make t 1 in
  stubs_normal_out2 (CArray.start out__) out mean std;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let normal_out3 ~out ~mean ~std ~size =
  let out__ = CArray.make t 1 in
  stubs_normal_out3
    (CArray.start out__)
    out
    mean
    std
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let not_equal self other =
  let out__ = CArray.make t 1 in
  stubs_not_equal (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let not_equal_ self other =
  let out__ = CArray.make t 1 in
  stubs_not_equal_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let not_equal_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_not_equal_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nuclear_norm self ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_nuclear_norm (CArray.start out__) self (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nuclear_norm1 self ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_nuclear_norm1
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nuclear_norm_out ~out self ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_nuclear_norm_out (CArray.start out__) out self (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let nuclear_norm_out1 ~out self ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_nuclear_norm_out1
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let numpy_t self =
  let out__ = CArray.make t 1 in
  stubs_numpy_t (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let one_hot self ~num_classes =
  let out__ = CArray.make t 1 in
  stubs_one_hot (CArray.start out__) self (Int64.of_int num_classes);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ones ~size ~options =
  let out__ = CArray.make t 1 in
  stubs_ones
    (CArray.start out__)
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ones_like self =
  let out__ = CArray.make t 1 in
  stubs_ones_like (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ones_out ~out ~size =
  let out__ = CArray.make t 1 in
  stubs_ones_out
    (CArray.start out__)
    out
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let orgqr self ~input2 =
  let out__ = CArray.make t 1 in
  stubs_orgqr (CArray.start out__) self input2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let orgqr_out ~out self ~input2 =
  let out__ = CArray.make t 1 in
  stubs_orgqr_out (CArray.start out__) out self input2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ormqr self ~input2 ~input3 ~left ~transpose =
  let out__ = CArray.make t 1 in
  stubs_ormqr
    (CArray.start out__)
    self
    input2
    input3
    (if left then 1 else 0)
    (if transpose then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ormqr_out ~out self ~input2 ~input3 ~left ~transpose =
  let out__ = CArray.make t 1 in
  stubs_ormqr_out
    (CArray.start out__)
    out
    self
    input2
    input3
    (if left then 1 else 0)
    (if transpose then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let outer self ~vec2 =
  let out__ = CArray.make t 1 in
  stubs_outer (CArray.start out__) self vec2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let outer_out ~out self ~vec2 =
  let out__ = CArray.make t 1 in
  stubs_outer_out (CArray.start out__) out self vec2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let pad_sequence ~sequences ~batch_first ~padding_value =
  let out__ = CArray.make t 1 in
  stubs_pad_sequence
    (CArray.start out__)
    (CArray.of_list t sequences |> CArray.start)
    (List.length sequences)
    (if batch_first then 1 else 0)
    padding_value;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let pairwise_distance ~x1 ~x2 ~p ~eps ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_pairwise_distance (CArray.start out__) x1 x2 p eps (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let pdist self ~p =
  let out__ = CArray.make t 1 in
  stubs_pdist (CArray.start out__) self p;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let permute self ~dims =
  let out__ = CArray.make t 1 in
  stubs_permute
    (CArray.start out__)
    self
    (List.map Int64.of_int dims |> CArray.of_list int64_t |> CArray.start)
    (List.length dims);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let pin_memory self =
  let out__ = CArray.make t 1 in
  stubs_pin_memory (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let pinverse self ~rcond =
  let out__ = CArray.make t 1 in
  stubs_pinverse (CArray.start out__) self rcond;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let pixel_shuffle self ~upscale_factor =
  let out__ = CArray.make t 1 in
  stubs_pixel_shuffle (CArray.start out__) self (Int64.of_int upscale_factor);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let pixel_unshuffle self ~downscale_factor =
  let out__ = CArray.make t 1 in
  stubs_pixel_unshuffle (CArray.start out__) self (Int64.of_int downscale_factor);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let poisson self =
  let out__ = CArray.make t 1 in
  stubs_poisson (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let poisson_nll_loss input ~target ~log_input ~full ~eps ~reduction =
  let out__ = CArray.make t 1 in
  stubs_poisson_nll_loss
    (CArray.start out__)
    input
    target
    (if log_input then 1 else 0)
    (if full then 1 else 0)
    eps
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let polar ~abs ~angle =
  let out__ = CArray.make t 1 in
  stubs_polar (CArray.start out__) abs angle;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let polar_out ~out ~abs ~angle =
  let out__ = CArray.make t 1 in
  stubs_polar_out (CArray.start out__) out abs angle;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let polygamma ~n self =
  let out__ = CArray.make t 1 in
  stubs_polygamma (CArray.start out__) (Int64.of_int n) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let polygamma_ self ~n =
  let out__ = CArray.make t 1 in
  stubs_polygamma_ (CArray.start out__) self (Int64.of_int n);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let polygamma_out ~out ~n self =
  let out__ = CArray.make t 1 in
  stubs_polygamma_out (CArray.start out__) out (Int64.of_int n) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let positive self =
  let out__ = CArray.make t 1 in
  stubs_positive (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let pow self ~exponent =
  let out__ = CArray.make t 1 in
  stubs_pow (CArray.start out__) self exponent;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let pow_ self ~exponent =
  let out__ = CArray.make t 1 in
  stubs_pow_ (CArray.start out__) self exponent;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let pow_out ~out self ~exponent =
  let out__ = CArray.make t 1 in
  stubs_pow_out (CArray.start out__) out self exponent;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let prelu self ~weight =
  let out__ = CArray.make t 1 in
  stubs_prelu (CArray.start out__) self weight;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let prelu_backward ~grad_output self ~weight =
  let out__ = CArray.make t 2 in
  stubs_prelu_backward (CArray.start out__) grad_output self weight;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let prod self ~dtype =
  let out__ = CArray.make t 1 in
  stubs_prod (CArray.start out__) self (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let prod1 self ~dim ~keepdim ~dtype =
  let out__ = CArray.make t 1 in
  stubs_prod1
    (CArray.start out__)
    self
    (Int64.of_int dim)
    (if keepdim then 1 else 0)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let prod_out ~out self ~dim ~keepdim ~dtype =
  let out__ = CArray.make t 1 in
  stubs_prod_out
    (CArray.start out__)
    out
    self
    (Int64.of_int dim)
    (if keepdim then 1 else 0)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let put self ~index ~source ~accumulate =
  let out__ = CArray.make t 1 in
  stubs_put (CArray.start out__) self index source (if accumulate then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let put_ self ~index ~source ~accumulate =
  let out__ = CArray.make t 1 in
  stubs_put_ (CArray.start out__) self index source (if accumulate then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let q_per_channel_scales self =
  let out__ = CArray.make t 1 in
  stubs_q_per_channel_scales (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let q_per_channel_zero_points self =
  let out__ = CArray.make t 1 in
  stubs_q_per_channel_zero_points (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let qr self ~some =
  let out__ = CArray.make t 2 in
  stubs_qr (CArray.start out__) self (if some then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let qr_out ~q ~r self ~some =
  let out__ = CArray.make t 2 in
  stubs_qr_out (CArray.start out__) q r self (if some then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let quantile self ~q ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_quantile (CArray.start out__) self q (Int64.of_int dim) (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let quantile1 self ~q ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_quantile1
    (CArray.start out__)
    self
    q
    (Int64.of_int dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let quantile2 self ~q ~dim ~keepdim ~interpolation =
  let out__ = CArray.make t 1 in
  stubs_quantile2
    (CArray.start out__)
    self
    q
    (Int64.of_int dim)
    (if keepdim then 1 else 0)
    interpolation;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let quantile3 self ~q ~dim ~keepdim ~interpolation =
  let out__ = CArray.make t 1 in
  stubs_quantile3
    (CArray.start out__)
    self
    q
    (Int64.of_int dim)
    (if keepdim then 1 else 0)
    interpolation;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let quantile_out ~out self ~q ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_quantile_out
    (CArray.start out__)
    out
    self
    q
    (Int64.of_int dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let quantile_out1 ~out self ~q ~dim ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_quantile_out1
    (CArray.start out__)
    out
    self
    q
    (Int64.of_int dim)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let quantile_out2 ~out self ~q ~dim ~keepdim ~interpolation =
  let out__ = CArray.make t 1 in
  stubs_quantile_out2
    (CArray.start out__)
    out
    self
    q
    (Int64.of_int dim)
    (if keepdim then 1 else 0)
    interpolation;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let quantile_out3 ~out self ~q ~dim ~keepdim ~interpolation =
  let out__ = CArray.make t 1 in
  stubs_quantile_out3
    (CArray.start out__)
    out
    self
    q
    (Int64.of_int dim)
    (if keepdim then 1 else 0)
    interpolation;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let quantize_per_channel self ~scales ~zero_points ~axis ~dtype =
  let out__ = CArray.make t 1 in
  stubs_quantize_per_channel
    (CArray.start out__)
    self
    scales
    zero_points
    (Int64.of_int axis)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let quantize_per_tensor self ~scale ~zero_point ~dtype =
  let out__ = CArray.make t 1 in
  stubs_quantize_per_tensor
    (CArray.start out__)
    self
    scale
    (Int64.of_int zero_point)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let quantize_per_tensor1 tensors ~scales ~zero_points ~dtype =
  stubs_quantize_per_tensor1
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors)
    scales
    zero_points
    (Kind.packed_to_int dtype)
  |> to_tensor_list

let quantized_batch_norm
    input
    ~weight
    ~bias
    ~mean
    ~var
    ~eps
    ~output_scale
    ~output_zero_point
  =
  let out__ = CArray.make t 1 in
  stubs_quantized_batch_norm
    (CArray.start out__)
    input
    (match weight with
    | Some v -> v
    | None -> null)
    (match bias with
    | Some v -> v
    | None -> null)
    mean
    var
    eps
    output_scale
    (Int64.of_int output_zero_point);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let quantized_max_pool1d self ~kernel_size ~stride ~padding ~dilation ~ceil_mode =
  let out__ = CArray.make t 1 in
  stubs_quantized_max_pool1d
    (CArray.start out__)
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if ceil_mode then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let quantized_max_pool2d self ~kernel_size ~stride ~padding ~dilation ~ceil_mode =
  let out__ = CArray.make t 1 in
  stubs_quantized_max_pool2d
    (CArray.start out__)
    self
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation)
    (if ceil_mode then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let rad2deg self =
  let out__ = CArray.make t 1 in
  stubs_rad2deg (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let rad2deg_ self =
  let out__ = CArray.make t 1 in
  stubs_rad2deg_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let rad2deg_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_rad2deg_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let rand ~size ~options =
  let out__ = CArray.make t 1 in
  stubs_rand
    (CArray.start out__)
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let rand_like self =
  let out__ = CArray.make t 1 in
  stubs_rand_like (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let rand_out ~out ~size =
  let out__ = CArray.make t 1 in
  stubs_rand_out
    (CArray.start out__)
    out
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let randint ~high ~size ~options =
  let out__ = CArray.make t 1 in
  stubs_randint
    (CArray.start out__)
    (Int64.of_int high)
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let randint1 ~low ~high ~size ~options =
  let out__ = CArray.make t 1 in
  stubs_randint1
    (CArray.start out__)
    (Int64.of_int low)
    (Int64.of_int high)
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let randint_like self ~high =
  let out__ = CArray.make t 1 in
  stubs_randint_like (CArray.start out__) self (Int64.of_int high);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let randint_like1 self ~low ~high =
  let out__ = CArray.make t 1 in
  stubs_randint_like1 (CArray.start out__) self (Int64.of_int low) (Int64.of_int high);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let randint_out ~out ~high ~size =
  let out__ = CArray.make t 1 in
  stubs_randint_out
    (CArray.start out__)
    out
    (Int64.of_int high)
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let randint_out1 ~out ~low ~high ~size =
  let out__ = CArray.make t 1 in
  stubs_randint_out1
    (CArray.start out__)
    out
    (Int64.of_int low)
    (Int64.of_int high)
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let randn ~size ~options =
  let out__ = CArray.make t 1 in
  stubs_randn
    (CArray.start out__)
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let randn_like self =
  let out__ = CArray.make t 1 in
  stubs_randn_like (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let randn_out ~out ~size =
  let out__ = CArray.make t 1 in
  stubs_randn_out
    (CArray.start out__)
    out
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let random_ self =
  let out__ = CArray.make t 1 in
  stubs_random_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let random_1 self ~to_ =
  let out__ = CArray.make t 1 in
  stubs_random_1 (CArray.start out__) self (Int64.of_int to_);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let random_2 self ~from ~to_ =
  let out__ = CArray.make t 1 in
  stubs_random_2 (CArray.start out__) self (Int64.of_int from) (Int64.of_int to_);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let randperm ~n ~options =
  let out__ = CArray.make t 1 in
  stubs_randperm
    (CArray.start out__)
    (Int64.of_int n)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let randperm_out ~out ~n =
  let out__ = CArray.make t 1 in
  stubs_randperm_out (CArray.start out__) out (Int64.of_int n);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let ravel self =
  let out__ = CArray.make t 1 in
  stubs_ravel (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let real self =
  let out__ = CArray.make t 1 in
  stubs_real (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let reciprocal self =
  let out__ = CArray.make t 1 in
  stubs_reciprocal (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let reciprocal_ self =
  let out__ = CArray.make t 1 in
  stubs_reciprocal_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let reciprocal_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_reciprocal_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let reflection_pad1d self ~padding =
  let out__ = CArray.make t 1 in
  stubs_reflection_pad1d
    (CArray.start out__)
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let reflection_pad1d_backward ~grad_output self ~padding =
  let out__ = CArray.make t 1 in
  stubs_reflection_pad1d_backward
    (CArray.start out__)
    grad_output
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let reflection_pad1d_backward_out ~grad_input ~grad_output self ~padding =
  let out__ = CArray.make t 1 in
  stubs_reflection_pad1d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let reflection_pad1d_out ~out self ~padding =
  let out__ = CArray.make t 1 in
  stubs_reflection_pad1d_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let reflection_pad2d self ~padding =
  let out__ = CArray.make t 1 in
  stubs_reflection_pad2d
    (CArray.start out__)
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let reflection_pad2d_backward ~grad_output self ~padding =
  let out__ = CArray.make t 1 in
  stubs_reflection_pad2d_backward
    (CArray.start out__)
    grad_output
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let reflection_pad2d_backward_out ~grad_input ~grad_output self ~padding =
  let out__ = CArray.make t 1 in
  stubs_reflection_pad2d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let reflection_pad2d_out ~out self ~padding =
  let out__ = CArray.make t 1 in
  stubs_reflection_pad2d_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let relu self =
  let out__ = CArray.make t 1 in
  stubs_relu (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let relu6 self =
  let out__ = CArray.make t 1 in
  stubs_relu6 (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let relu6_ self =
  let out__ = CArray.make t 1 in
  stubs_relu6_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let relu_ self =
  let out__ = CArray.make t 1 in
  stubs_relu_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let remainder self other =
  let out__ = CArray.make t 1 in
  stubs_remainder (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let remainder_ self other =
  let out__ = CArray.make t 1 in
  stubs_remainder_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let remainder_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_remainder_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let repeat self ~repeats =
  let out__ = CArray.make t 1 in
  stubs_repeat
    (CArray.start out__)
    self
    (List.map Int64.of_int repeats |> CArray.of_list int64_t |> CArray.start)
    (List.length repeats);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let repeat_interleave ~repeats =
  let out__ = CArray.make t 1 in
  stubs_repeat_interleave (CArray.start out__) repeats;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let repeat_interleave1 self ~repeats ~dim =
  let out__ = CArray.make t 1 in
  stubs_repeat_interleave1 (CArray.start out__) self repeats (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let repeat_interleave2 self ~repeats ~dim =
  let out__ = CArray.make t 1 in
  stubs_repeat_interleave2
    (CArray.start out__)
    self
    (Int64.of_int repeats)
    (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let replication_pad1d self ~padding =
  let out__ = CArray.make t 1 in
  stubs_replication_pad1d
    (CArray.start out__)
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let replication_pad1d_backward ~grad_output self ~padding =
  let out__ = CArray.make t 1 in
  stubs_replication_pad1d_backward
    (CArray.start out__)
    grad_output
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let replication_pad1d_backward_out ~grad_input ~grad_output self ~padding =
  let out__ = CArray.make t 1 in
  stubs_replication_pad1d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let replication_pad1d_out ~out self ~padding =
  let out__ = CArray.make t 1 in
  stubs_replication_pad1d_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let replication_pad2d self ~padding =
  let out__ = CArray.make t 1 in
  stubs_replication_pad2d
    (CArray.start out__)
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let replication_pad2d_backward ~grad_output self ~padding =
  let out__ = CArray.make t 1 in
  stubs_replication_pad2d_backward
    (CArray.start out__)
    grad_output
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let replication_pad2d_backward_out ~grad_input ~grad_output self ~padding =
  let out__ = CArray.make t 1 in
  stubs_replication_pad2d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let replication_pad2d_out ~out self ~padding =
  let out__ = CArray.make t 1 in
  stubs_replication_pad2d_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let replication_pad3d self ~padding =
  let out__ = CArray.make t 1 in
  stubs_replication_pad3d
    (CArray.start out__)
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let replication_pad3d_backward ~grad_output self ~padding =
  let out__ = CArray.make t 1 in
  stubs_replication_pad3d_backward
    (CArray.start out__)
    grad_output
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let replication_pad3d_backward_out ~grad_input ~grad_output self ~padding =
  let out__ = CArray.make t 1 in
  stubs_replication_pad3d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let replication_pad3d_out ~out self ~padding =
  let out__ = CArray.make t 1 in
  stubs_replication_pad3d_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let requires_grad_ self ~requires_grad =
  let out__ = CArray.make t 1 in
  stubs_requires_grad_ (CArray.start out__) self (if requires_grad then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let reshape self ~shape =
  let out__ = CArray.make t 1 in
  stubs_reshape
    (CArray.start out__)
    self
    (List.map Int64.of_int shape |> CArray.of_list int64_t |> CArray.start)
    (List.length shape);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let reshape_as self other =
  let out__ = CArray.make t 1 in
  stubs_reshape_as (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let resize_ self ~size =
  let out__ = CArray.make t 1 in
  stubs_resize_
    (CArray.start out__)
    self
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let resize_as_ self ~the_template =
  let out__ = CArray.make t 1 in
  stubs_resize_as_ (CArray.start out__) self the_template;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let resize_as_sparse_ self ~the_template =
  let out__ = CArray.make t 1 in
  stubs_resize_as_sparse_ (CArray.start out__) self the_template;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let rnn_relu
    input
    ~hx
    ~params
    ~has_biases
    ~num_layers
    ~dropout
    ~train
    ~bidirectional
    ~batch_first
  =
  let out__ = CArray.make t 2 in
  stubs_rnn_relu
    (CArray.start out__)
    input
    hx
    (CArray.of_list t params |> CArray.start)
    (List.length params)
    (if has_biases then 1 else 0)
    (Int64.of_int num_layers)
    dropout
    (if train then 1 else 0)
    (if bidirectional then 1 else 0)
    (if batch_first then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let rnn_relu1
    ~data
    ~batch_sizes
    ~hx
    ~params
    ~has_biases
    ~num_layers
    ~dropout
    ~train
    ~bidirectional
  =
  let out__ = CArray.make t 2 in
  stubs_rnn_relu1
    (CArray.start out__)
    data
    batch_sizes
    hx
    (CArray.of_list t params |> CArray.start)
    (List.length params)
    (if has_biases then 1 else 0)
    (Int64.of_int num_layers)
    dropout
    (if train then 1 else 0)
    (if bidirectional then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let rnn_relu_cell input ~hx ~w_ih ~w_hh ~b_ih ~b_hh =
  let out__ = CArray.make t 1 in
  stubs_rnn_relu_cell
    (CArray.start out__)
    input
    hx
    w_ih
    w_hh
    (match b_ih with
    | Some v -> v
    | None -> null)
    (match b_hh with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let rnn_tanh
    input
    ~hx
    ~params
    ~has_biases
    ~num_layers
    ~dropout
    ~train
    ~bidirectional
    ~batch_first
  =
  let out__ = CArray.make t 2 in
  stubs_rnn_tanh
    (CArray.start out__)
    input
    hx
    (CArray.of_list t params |> CArray.start)
    (List.length params)
    (if has_biases then 1 else 0)
    (Int64.of_int num_layers)
    dropout
    (if train then 1 else 0)
    (if bidirectional then 1 else 0)
    (if batch_first then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let rnn_tanh1
    ~data
    ~batch_sizes
    ~hx
    ~params
    ~has_biases
    ~num_layers
    ~dropout
    ~train
    ~bidirectional
  =
  let out__ = CArray.make t 2 in
  stubs_rnn_tanh1
    (CArray.start out__)
    data
    batch_sizes
    hx
    (CArray.of_list t params |> CArray.start)
    (List.length params)
    (if has_biases then 1 else 0)
    (Int64.of_int num_layers)
    dropout
    (if train then 1 else 0)
    (if bidirectional then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let rnn_tanh_cell input ~hx ~w_ih ~w_hh ~b_ih ~b_hh =
  let out__ = CArray.make t 1 in
  stubs_rnn_tanh_cell
    (CArray.start out__)
    input
    hx
    w_ih
    w_hh
    (match b_ih with
    | Some v -> v
    | None -> null)
    (match b_hh with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let roll self ~shifts ~dims =
  let out__ = CArray.make t 1 in
  stubs_roll
    (CArray.start out__)
    self
    (List.map Int64.of_int shifts |> CArray.of_list int64_t |> CArray.start)
    (List.length shifts)
    (List.map Int64.of_int dims |> CArray.of_list int64_t |> CArray.start)
    (List.length dims);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let rot90 self ~k ~dims =
  let out__ = CArray.make t 1 in
  stubs_rot90
    (CArray.start out__)
    self
    (Int64.of_int k)
    (List.map Int64.of_int dims |> CArray.of_list int64_t |> CArray.start)
    (List.length dims);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let round self =
  let out__ = CArray.make t 1 in
  stubs_round (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let round_ self =
  let out__ = CArray.make t 1 in
  stubs_round_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let round_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_round_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let row_stack tensors =
  let out__ = CArray.make t 1 in
  stubs_row_stack
    (CArray.start out__)
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let row_stack_out ~out tensors =
  let out__ = CArray.make t 1 in
  stubs_row_stack_out
    (CArray.start out__)
    out
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let rrelu self ~training =
  let out__ = CArray.make t 1 in
  stubs_rrelu (CArray.start out__) self (if training then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let rrelu_ self ~training =
  let out__ = CArray.make t 1 in
  stubs_rrelu_ (CArray.start out__) self (if training then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let rrelu_with_noise self ~noise ~training =
  let out__ = CArray.make t 1 in
  stubs_rrelu_with_noise (CArray.start out__) self noise (if training then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let rrelu_with_noise_ self ~noise ~training =
  let out__ = CArray.make t 1 in
  stubs_rrelu_with_noise_ (CArray.start out__) self noise (if training then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let rrelu_with_noise_out ~out self ~noise ~training =
  let out__ = CArray.make t 1 in
  stubs_rrelu_with_noise_out
    (CArray.start out__)
    out
    self
    noise
    (if training then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let rsqrt self =
  let out__ = CArray.make t 1 in
  stubs_rsqrt (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let rsqrt_ self =
  let out__ = CArray.make t 1 in
  stubs_rsqrt_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let rsqrt_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_rsqrt_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let rsub self other =
  let out__ = CArray.make t 1 in
  stubs_rsub (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let scatter self ~dim ~index ~src =
  let out__ = CArray.make t 1 in
  stubs_scatter (CArray.start out__) self (Int64.of_int dim) index src;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let scatter_ self ~dim ~index ~src =
  let out__ = CArray.make t 1 in
  stubs_scatter_ (CArray.start out__) self (Int64.of_int dim) index src;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let scatter_1 self ~dim ~index ~src ~reduce =
  let out__ = CArray.make t 1 in
  stubs_scatter_1 (CArray.start out__) self (Int64.of_int dim) index src reduce;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let scatter_add self ~dim ~index ~src =
  let out__ = CArray.make t 1 in
  stubs_scatter_add (CArray.start out__) self (Int64.of_int dim) index src;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let scatter_add_ self ~dim ~index ~src =
  let out__ = CArray.make t 1 in
  stubs_scatter_add_ (CArray.start out__) self (Int64.of_int dim) index src;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let searchsorted ~sorted_sequence self ~out_int32 ~right =
  let out__ = CArray.make t 1 in
  stubs_searchsorted
    (CArray.start out__)
    sorted_sequence
    self
    (if out_int32 then 1 else 0)
    (if right then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let searchsorted_out ~out ~sorted_sequence self ~out_int32 ~right =
  let out__ = CArray.make t 1 in
  stubs_searchsorted_out
    (CArray.start out__)
    out
    sorted_sequence
    self
    (if out_int32 then 1 else 0)
    (if right then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let segment_reduce ~data ~reduce ~lengths ~indices ~axis ~unsafe =
  let out__ = CArray.make t 1 in
  stubs_segment_reduce
    (CArray.start out__)
    data
    reduce
    (match lengths with
    | Some v -> v
    | None -> null)
    (match indices with
    | Some v -> v
    | None -> null)
    (Int64.of_int axis)
    (if unsafe then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let segment_reduce_backward ~grad ~output ~data ~lengths =
  let out__ = CArray.make t 1 in
  stubs_segment_reduce_backward
    (CArray.start out__)
    grad
    output
    data
    (match lengths with
    | Some v -> v
    | None -> null);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let select self ~dim ~index =
  let out__ = CArray.make t 1 in
  stubs_select (CArray.start out__) self (Int64.of_int dim) (Int64.of_int index);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let select_backward ~grad ~input_sizes ~dim ~index =
  let out__ = CArray.make t 1 in
  stubs_select_backward
    (CArray.start out__)
    grad
    (List.map Int64.of_int input_sizes |> CArray.of_list int64_t |> CArray.start)
    (List.length input_sizes)
    (Int64.of_int dim)
    (Int64.of_int index);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let selu self =
  let out__ = CArray.make t 1 in
  stubs_selu (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let selu_ self =
  let out__ = CArray.make t 1 in
  stubs_selu_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let set_ self =
  let out__ = CArray.make t 1 in
  stubs_set_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let set_1 self ~source =
  let out__ = CArray.make t 1 in
  stubs_set_1 (CArray.start out__) self source;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let set_requires_grad self ~r =
  let out__ = CArray.make t 1 in
  stubs_set_requires_grad (CArray.start out__) self (if r then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sgn self =
  let out__ = CArray.make t 1 in
  stubs_sgn (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sgn_ self =
  let out__ = CArray.make t 1 in
  stubs_sgn_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sgn_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_sgn_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sigmoid self =
  let out__ = CArray.make t 1 in
  stubs_sigmoid (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sigmoid_ self =
  let out__ = CArray.make t 1 in
  stubs_sigmoid_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sigmoid_backward ~grad_output ~output =
  let out__ = CArray.make t 1 in
  stubs_sigmoid_backward (CArray.start out__) grad_output output;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sigmoid_backward_out ~grad_input ~grad_output ~output =
  let out__ = CArray.make t 1 in
  stubs_sigmoid_backward_out (CArray.start out__) grad_input grad_output output;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sigmoid_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_sigmoid_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sign self =
  let out__ = CArray.make t 1 in
  stubs_sign (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sign_ self =
  let out__ = CArray.make t 1 in
  stubs_sign_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sign_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_sign_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let signbit self =
  let out__ = CArray.make t 1 in
  stubs_signbit (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let signbit_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_signbit_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let silu self =
  let out__ = CArray.make t 1 in
  stubs_silu (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let silu_ self =
  let out__ = CArray.make t 1 in
  stubs_silu_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let silu_backward ~grad_output self =
  let out__ = CArray.make t 1 in
  stubs_silu_backward (CArray.start out__) grad_output self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let silu_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_silu_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sin self =
  let out__ = CArray.make t 1 in
  stubs_sin (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sin_ self =
  let out__ = CArray.make t 1 in
  stubs_sin_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sin_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_sin_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sinc self =
  let out__ = CArray.make t 1 in
  stubs_sinc (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sinc_ self =
  let out__ = CArray.make t 1 in
  stubs_sinc_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sinc_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_sinc_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sinh self =
  let out__ = CArray.make t 1 in
  stubs_sinh (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sinh_ self =
  let out__ = CArray.make t 1 in
  stubs_sinh_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sinh_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_sinh_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let slice self ~dim ~start ~end_ ~step =
  let out__ = CArray.make t 1 in
  stubs_slice
    (CArray.start out__)
    self
    (Int64.of_int dim)
    (Int64.of_int start)
    (Int64.of_int end_)
    (Int64.of_int step);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let slice_backward ~grad ~input_sizes ~dim ~start ~end_ ~step =
  let out__ = CArray.make t 1 in
  stubs_slice_backward
    (CArray.start out__)
    grad
    (List.map Int64.of_int input_sizes |> CArray.of_list int64_t |> CArray.start)
    (List.length input_sizes)
    (Int64.of_int dim)
    (Int64.of_int start)
    (Int64.of_int end_)
    (Int64.of_int step);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let slogdet self =
  let out__ = CArray.make t 2 in
  stubs_slogdet (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let slow_conv3d self ~weight ~kernel_size ~bias ~stride ~padding =
  let out__ = CArray.make t 1 in
  stubs_slow_conv3d
    (CArray.start out__)
    self
    weight
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let slow_conv3d_out ~out self ~weight ~kernel_size ~bias ~stride ~padding =
  let out__ = CArray.make t 1 in
  stubs_slow_conv3d_out
    (CArray.start out__)
    out
    self
    weight
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let slow_conv_dilated2d self ~weight ~kernel_size ~bias ~stride ~padding ~dilation =
  let out__ = CArray.make t 1 in
  stubs_slow_conv_dilated2d
    (CArray.start out__)
    self
    weight
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let slow_conv_dilated3d self ~weight ~kernel_size ~bias ~stride ~padding ~dilation =
  let out__ = CArray.make t 1 in
  stubs_slow_conv_dilated3d
    (CArray.start out__)
    self
    weight
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let slow_conv_transpose2d
    self
    ~weight
    ~kernel_size
    ~bias
    ~stride
    ~padding
    ~output_padding
    ~dilation
  =
  let out__ = CArray.make t 1 in
  stubs_slow_conv_transpose2d
    (CArray.start out__)
    self
    weight
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int output_padding |> CArray.of_list int64_t |> CArray.start)
    (List.length output_padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let slow_conv_transpose2d_out
    ~out
    self
    ~weight
    ~kernel_size
    ~bias
    ~stride
    ~padding
    ~output_padding
    ~dilation
  =
  let out__ = CArray.make t 1 in
  stubs_slow_conv_transpose2d_out
    (CArray.start out__)
    out
    self
    weight
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int output_padding |> CArray.of_list int64_t |> CArray.start)
    (List.length output_padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let slow_conv_transpose3d
    self
    ~weight
    ~kernel_size
    ~bias
    ~stride
    ~padding
    ~output_padding
    ~dilation
  =
  let out__ = CArray.make t 1 in
  stubs_slow_conv_transpose3d
    (CArray.start out__)
    self
    weight
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int output_padding |> CArray.of_list int64_t |> CArray.start)
    (List.length output_padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let slow_conv_transpose3d_out
    ~out
    self
    ~weight
    ~kernel_size
    ~bias
    ~stride
    ~padding
    ~output_padding
    ~dilation
  =
  let out__ = CArray.make t 1 in
  stubs_slow_conv_transpose3d_out
    (CArray.start out__)
    out
    self
    weight
    (List.map Int64.of_int kernel_size |> CArray.of_list int64_t |> CArray.start)
    (List.length kernel_size)
    (match bias with
    | Some v -> v
    | None -> null)
    (List.map Int64.of_int stride |> CArray.of_list int64_t |> CArray.start)
    (List.length stride)
    (List.map Int64.of_int padding |> CArray.of_list int64_t |> CArray.start)
    (List.length padding)
    (List.map Int64.of_int output_padding |> CArray.of_list int64_t |> CArray.start)
    (List.length output_padding)
    (List.map Int64.of_int dilation |> CArray.of_list int64_t |> CArray.start)
    (List.length dilation);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let smm self ~mat2 =
  let out__ = CArray.make t 1 in
  stubs_smm (CArray.start out__) self mat2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let smooth_l1_loss self ~target ~reduction ~beta =
  let out__ = CArray.make t 1 in
  stubs_smooth_l1_loss
    (CArray.start out__)
    self
    target
    (Reduction.to_int reduction |> Int64.of_int)
    beta;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let smooth_l1_loss_backward ~grad_output self ~target ~reduction ~beta =
  let out__ = CArray.make t 1 in
  stubs_smooth_l1_loss_backward
    (CArray.start out__)
    grad_output
    self
    target
    (Reduction.to_int reduction |> Int64.of_int)
    beta;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let smooth_l1_loss_backward_out ~grad_input ~grad_output self ~target ~reduction ~beta =
  let out__ = CArray.make t 1 in
  stubs_smooth_l1_loss_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    target
    (Reduction.to_int reduction |> Int64.of_int)
    beta;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let smooth_l1_loss_out ~out self ~target ~reduction ~beta =
  let out__ = CArray.make t 1 in
  stubs_smooth_l1_loss_out
    (CArray.start out__)
    out
    self
    target
    (Reduction.to_int reduction |> Int64.of_int)
    beta;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let soft_margin_loss self ~target ~reduction =
  let out__ = CArray.make t 1 in
  stubs_soft_margin_loss
    (CArray.start out__)
    self
    target
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let soft_margin_loss_backward ~grad_output self ~target ~reduction =
  let out__ = CArray.make t 1 in
  stubs_soft_margin_loss_backward
    (CArray.start out__)
    grad_output
    self
    target
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let soft_margin_loss_backward_out ~grad_input ~grad_output self ~target ~reduction =
  let out__ = CArray.make t 1 in
  stubs_soft_margin_loss_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    self
    target
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let soft_margin_loss_out ~out self ~target ~reduction =
  let out__ = CArray.make t 1 in
  stubs_soft_margin_loss_out
    (CArray.start out__)
    out
    self
    target
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let softmax self ~dim ~dtype =
  let out__ = CArray.make t 1 in
  stubs_softmax (CArray.start out__) self (Int64.of_int dim) (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let softplus self =
  let out__ = CArray.make t 1 in
  stubs_softplus (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let softplus_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_softplus_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let softshrink self =
  let out__ = CArray.make t 1 in
  stubs_softshrink (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let softshrink_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_softshrink_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let solve self ~a =
  let out__ = CArray.make t 2 in
  stubs_solve (CArray.start out__) self a;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let solve_out ~solution ~lu self ~a =
  let out__ = CArray.make t 2 in
  stubs_solve_out (CArray.start out__) solution lu self a;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let sort self ~dim ~descending =
  let out__ = CArray.make t 2 in
  stubs_sort (CArray.start out__) self (Int64.of_int dim) (if descending then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let sort1 self ~stable ~dim ~descending =
  let out__ = CArray.make t 2 in
  stubs_sort1
    (CArray.start out__)
    self
    (if stable then 1 else 0)
    (Int64.of_int dim)
    (if descending then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let sort_out ~values ~indices self ~dim ~descending =
  let out__ = CArray.make t 2 in
  stubs_sort_out
    (CArray.start out__)
    values
    indices
    self
    (Int64.of_int dim)
    (if descending then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let sort_out1 ~values ~indices self ~stable ~dim ~descending =
  let out__ = CArray.make t 2 in
  stubs_sort_out1
    (CArray.start out__)
    values
    indices
    self
    (if stable then 1 else 0)
    (Int64.of_int dim)
    (if descending then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let sparse_coo_tensor ~size ~options =
  let out__ = CArray.make t 1 in
  stubs_sparse_coo_tensor
    (CArray.start out__)
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sparse_coo_tensor1 ~indices ~values ~options =
  let out__ = CArray.make t 1 in
  stubs_sparse_coo_tensor1
    (CArray.start out__)
    indices
    values
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sparse_coo_tensor2 ~indices ~values ~size ~options =
  let out__ = CArray.make t 1 in
  stubs_sparse_coo_tensor2
    (CArray.start out__)
    indices
    values
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sparse_mask self ~mask =
  let out__ = CArray.make t 1 in
  stubs_sparse_mask (CArray.start out__) self mask;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sparse_resize_ self ~size ~sparse_dim ~dense_dim =
  let out__ = CArray.make t 1 in
  stubs_sparse_resize_
    (CArray.start out__)
    self
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (Int64.of_int sparse_dim)
    (Int64.of_int dense_dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sparse_resize_and_clear_ self ~size ~sparse_dim ~dense_dim =
  let out__ = CArray.make t 1 in
  stubs_sparse_resize_and_clear_
    (CArray.start out__)
    self
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (Int64.of_int sparse_dim)
    (Int64.of_int dense_dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_entr self =
  let out__ = CArray.make t 1 in
  stubs_special_entr (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_entr_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_special_entr_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_erf self =
  let out__ = CArray.make t 1 in
  stubs_special_erf (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_erf_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_special_erf_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_erfc self =
  let out__ = CArray.make t 1 in
  stubs_special_erfc (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_erfc_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_special_erfc_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_erfinv self =
  let out__ = CArray.make t 1 in
  stubs_special_erfinv (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_erfinv_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_special_erfinv_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_exp2 self =
  let out__ = CArray.make t 1 in
  stubs_special_exp2 (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_exp2_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_special_exp2_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_expit self =
  let out__ = CArray.make t 1 in
  stubs_special_expit (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_expit_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_special_expit_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_expm1 self =
  let out__ = CArray.make t 1 in
  stubs_special_expm1 (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_expm1_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_special_expm1_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_gammaln self =
  let out__ = CArray.make t 1 in
  stubs_special_gammaln (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_gammaln_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_special_gammaln_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_i0e self =
  let out__ = CArray.make t 1 in
  stubs_special_i0e (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_i0e_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_special_i0e_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_logit self ~eps =
  let out__ = CArray.make t 1 in
  stubs_special_logit (CArray.start out__) self eps;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_logit_out ~out self ~eps =
  let out__ = CArray.make t 1 in
  stubs_special_logit_out (CArray.start out__) out self eps;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_xlog1py self other =
  let out__ = CArray.make t 1 in
  stubs_special_xlog1py (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let special_xlog1py_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_special_xlog1py_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let split self ~split_size ~dim =
  stubs_split self (Int64.of_int split_size) (Int64.of_int dim) |> to_tensor_list

let split_with_sizes self ~split_sizes ~dim =
  stubs_split_with_sizes
    self
    (List.map Int64.of_int split_sizes |> CArray.of_list int64_t |> CArray.start)
    (List.length split_sizes)
    (Int64.of_int dim)
  |> to_tensor_list

let sqrt self =
  let out__ = CArray.make t 1 in
  stubs_sqrt (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sqrt_ self =
  let out__ = CArray.make t 1 in
  stubs_sqrt_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sqrt_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_sqrt_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let square self =
  let out__ = CArray.make t 1 in
  stubs_square (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let square_ self =
  let out__ = CArray.make t 1 in
  stubs_square_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let square_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_square_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let squeeze self =
  let out__ = CArray.make t 1 in
  stubs_squeeze (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let squeeze1 self ~dim =
  let out__ = CArray.make t 1 in
  stubs_squeeze1 (CArray.start out__) self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let squeeze_ self =
  let out__ = CArray.make t 1 in
  stubs_squeeze_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let squeeze_1 self ~dim =
  let out__ = CArray.make t 1 in
  stubs_squeeze_1 (CArray.start out__) self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sspaddmm self ~mat1 ~mat2 =
  let out__ = CArray.make t 1 in
  stubs_sspaddmm (CArray.start out__) self mat1 mat2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sspaddmm_out ~out self ~mat1 ~mat2 =
  let out__ = CArray.make t 1 in
  stubs_sspaddmm_out (CArray.start out__) out self mat1 mat2;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let stack tensors ~dim =
  let out__ = CArray.make t 1 in
  stubs_stack
    (CArray.start out__)
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors)
    (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let stack_out ~out tensors ~dim =
  let out__ = CArray.make t 1 in
  stubs_stack_out
    (CArray.start out__)
    out
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors)
    (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let std self ~unbiased =
  let out__ = CArray.make t 1 in
  stubs_std (CArray.start out__) self (if unbiased then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let std1 self ~dim ~unbiased ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_std1
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if unbiased then 1 else 0)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let std2 self ~dim ~correction ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_std2
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (Int64.of_int correction)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let std_mean self ~unbiased =
  let out__ = CArray.make t 2 in
  stubs_std_mean (CArray.start out__) self (if unbiased then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let std_mean1 self ~dim ~unbiased ~keepdim =
  let out__ = CArray.make t 2 in
  stubs_std_mean1
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if unbiased then 1 else 0)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let std_mean2 self ~dim ~correction ~keepdim =
  let out__ = CArray.make t 2 in
  stubs_std_mean2
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (Int64.of_int correction)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let std_out ~out self ~dim ~unbiased ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_std_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if unbiased then 1 else 0)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let std_out1 ~out self ~dim ~correction ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_std_out1
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (Int64.of_int correction)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let stft self ~n_fft ~hop_length ~win_length ~window ~normalized ~onesided ~return_complex
  =
  let out__ = CArray.make t 1 in
  stubs_stft
    (CArray.start out__)
    self
    (Int64.of_int n_fft)
    (Int64.of_int hop_length)
    (Int64.of_int win_length)
    (match window with
    | Some v -> v
    | None -> null)
    (if normalized then 1 else 0)
    (if onesided then 1 else 0)
    (if return_complex then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sub self other =
  let out__ = CArray.make t 1 in
  stubs_sub (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sub_ self other =
  let out__ = CArray.make t 1 in
  stubs_sub_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sub_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_sub_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let subtract self other =
  let out__ = CArray.make t 1 in
  stubs_subtract (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let subtract_ self other =
  let out__ = CArray.make t 1 in
  stubs_subtract_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let subtract_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_subtract_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sum self ~dtype =
  let out__ = CArray.make t 1 in
  stubs_sum (CArray.start out__) self (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sum1 self ~dim ~keepdim ~dtype =
  let out__ = CArray.make t 1 in
  stubs_sum1
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if keepdim then 1 else 0)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sum_out ~out self ~dim ~keepdim ~dtype =
  let out__ = CArray.make t 1 in
  stubs_sum_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if keepdim then 1 else 0)
    (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let sum_to_size self ~size =
  let out__ = CArray.make t 1 in
  stubs_sum_to_size
    (CArray.start out__)
    self
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let svd self ~some ~compute_uv =
  let out__ = CArray.make t 3 in
  stubs_svd
    (CArray.start out__)
    self
    (if some then 1 else 0)
    (if compute_uv then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let svd_out ~u ~s ~v self ~some ~compute_uv =
  let out__ = CArray.make t 3 in
  stubs_svd_out
    (CArray.start out__)
    u
    s
    v
    self
    (if some then 1 else 0)
    (if compute_uv then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let swapaxes self ~axis0 ~axis1 =
  let out__ = CArray.make t 1 in
  stubs_swapaxes (CArray.start out__) self (Int64.of_int axis0) (Int64.of_int axis1);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let swapaxes_ self ~axis0 ~axis1 =
  let out__ = CArray.make t 1 in
  stubs_swapaxes_ (CArray.start out__) self (Int64.of_int axis0) (Int64.of_int axis1);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let swapdims self ~dim0 ~dim1 =
  let out__ = CArray.make t 1 in
  stubs_swapdims (CArray.start out__) self (Int64.of_int dim0) (Int64.of_int dim1);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let swapdims_ self ~dim0 ~dim1 =
  let out__ = CArray.make t 1 in
  stubs_swapdims_ (CArray.start out__) self (Int64.of_int dim0) (Int64.of_int dim1);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let symeig self ~eigenvectors ~upper =
  let out__ = CArray.make t 2 in
  stubs_symeig
    (CArray.start out__)
    self
    (if eigenvectors then 1 else 0)
    (if upper then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let symeig_out ~e ~v self ~eigenvectors ~upper =
  let out__ = CArray.make t 2 in
  stubs_symeig_out
    (CArray.start out__)
    e
    v
    self
    (if eigenvectors then 1 else 0)
    (if upper then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let tr self =
  let out__ = CArray.make t 1 in
  stubs_tr (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let t_ self =
  let out__ = CArray.make t 1 in
  stubs_t_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let take self ~index =
  let out__ = CArray.make t 1 in
  stubs_take (CArray.start out__) self index;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let take_along_dim self ~indices ~dim =
  let out__ = CArray.make t 1 in
  stubs_take_along_dim (CArray.start out__) self indices (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let take_along_dim_out ~out self ~indices ~dim =
  let out__ = CArray.make t 1 in
  stubs_take_along_dim_out (CArray.start out__) out self indices (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let take_out ~out self ~index =
  let out__ = CArray.make t 1 in
  stubs_take_out (CArray.start out__) out self index;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let tan self =
  let out__ = CArray.make t 1 in
  stubs_tan (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let tan_ self =
  let out__ = CArray.make t 1 in
  stubs_tan_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let tan_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_tan_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let tanh self =
  let out__ = CArray.make t 1 in
  stubs_tanh (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let tanh_ self =
  let out__ = CArray.make t 1 in
  stubs_tanh_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let tanh_backward ~grad_output ~output =
  let out__ = CArray.make t 1 in
  stubs_tanh_backward (CArray.start out__) grad_output output;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let tanh_backward_out ~grad_input ~grad_output ~output =
  let out__ = CArray.make t 1 in
  stubs_tanh_backward_out (CArray.start out__) grad_input grad_output output;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let tanh_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_tanh_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let tensor_split self ~sections ~dim =
  stubs_tensor_split self (Int64.of_int sections) (Int64.of_int dim) |> to_tensor_list

let tensor_split1 self ~indices ~dim =
  stubs_tensor_split1
    self
    (List.map Int64.of_int indices |> CArray.of_list int64_t |> CArray.start)
    (List.length indices)
    (Int64.of_int dim)
  |> to_tensor_list

let tensor_split2 self ~tensor_indices_or_sections ~dim =
  stubs_tensor_split2 self tensor_indices_or_sections (Int64.of_int dim) |> to_tensor_list

let tensordot self other ~dims_self ~dims_other =
  let out__ = CArray.make t 1 in
  stubs_tensordot
    (CArray.start out__)
    self
    other
    (List.map Int64.of_int dims_self |> CArray.of_list int64_t |> CArray.start)
    (List.length dims_self)
    (List.map Int64.of_int dims_other |> CArray.of_list int64_t |> CArray.start)
    (List.length dims_other);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let tensordot_out ~out self other ~dims_self ~dims_other =
  let out__ = CArray.make t 1 in
  stubs_tensordot_out
    (CArray.start out__)
    out
    self
    other
    (List.map Int64.of_int dims_self |> CArray.of_list int64_t |> CArray.start)
    (List.length dims_self)
    (List.map Int64.of_int dims_other |> CArray.of_list int64_t |> CArray.start)
    (List.length dims_other);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let tile self ~dims =
  let out__ = CArray.make t 1 in
  stubs_tile
    (CArray.start out__)
    self
    (List.map Int64.of_int dims |> CArray.of_list int64_t |> CArray.start)
    (List.length dims);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let to_ self ~device =
  let out__ = CArray.make t 1 in
  stubs_to_ (CArray.start out__) self (Device.to_int device);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let to1 self ~options ~non_blocking ~copy =
  let out__ = CArray.make t 1 in
  stubs_to1
    (CArray.start out__)
    self
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options))
    (if non_blocking then 1 else 0)
    (if copy then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let to2 self ~dtype ~non_blocking ~copy =
  let out__ = CArray.make t 1 in
  stubs_to2
    (CArray.start out__)
    self
    (Kind.packed_to_int dtype)
    (if non_blocking then 1 else 0)
    (if copy then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let to3 self other ~non_blocking ~copy =
  let out__ = CArray.make t 1 in
  stubs_to3
    (CArray.start out__)
    self
    other
    (if non_blocking then 1 else 0)
    (if copy then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let to4 self ~device ~dtype ~non_blocking ~copy =
  let out__ = CArray.make t 1 in
  stubs_to4
    (CArray.start out__)
    self
    (Device.to_int device)
    (Kind.packed_to_int dtype)
    (if non_blocking then 1 else 0)
    (if copy then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let to_dense self ~dtype =
  let out__ = CArray.make t 1 in
  stubs_to_dense (CArray.start out__) self (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let to_dense_backward ~grad input =
  let out__ = CArray.make t 1 in
  stubs_to_dense_backward (CArray.start out__) grad input;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let to_mkldnn self ~dtype =
  let out__ = CArray.make t 1 in
  stubs_to_mkldnn (CArray.start out__) self (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let to_mkldnn_backward ~grad input =
  let out__ = CArray.make t 1 in
  stubs_to_mkldnn_backward (CArray.start out__) grad input;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let to_sparse self =
  let out__ = CArray.make t 1 in
  stubs_to_sparse (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let to_sparse1 self ~sparse_dim =
  let out__ = CArray.make t 1 in
  stubs_to_sparse1 (CArray.start out__) self (Int64.of_int sparse_dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let topk self ~k ~dim ~largest ~sorted =
  let out__ = CArray.make t 2 in
  stubs_topk
    (CArray.start out__)
    self
    (Int64.of_int k)
    (Int64.of_int dim)
    (if largest then 1 else 0)
    (if sorted then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let topk_out ~values ~indices self ~k ~dim ~largest ~sorted =
  let out__ = CArray.make t 2 in
  stubs_topk_out
    (CArray.start out__)
    values
    indices
    self
    (Int64.of_int k)
    (Int64.of_int dim)
    (if largest then 1 else 0)
    (if sorted then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let totype self ~scalar_type =
  let out__ = CArray.make t 1 in
  stubs_totype (CArray.start out__) self (Kind.packed_to_int scalar_type);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let trace self =
  let out__ = CArray.make t 1 in
  stubs_trace (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let trace_backward ~grad ~sizes =
  let out__ = CArray.make t 1 in
  stubs_trace_backward
    (CArray.start out__)
    grad
    (List.map Int64.of_int sizes |> CArray.of_list int64_t |> CArray.start)
    (List.length sizes);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let transpose self ~dim0 ~dim1 =
  let out__ = CArray.make t 1 in
  stubs_transpose (CArray.start out__) self (Int64.of_int dim0) (Int64.of_int dim1);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let transpose_ self ~dim0 ~dim1 =
  let out__ = CArray.make t 1 in
  stubs_transpose_ (CArray.start out__) self (Int64.of_int dim0) (Int64.of_int dim1);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let trapz ~y ~x ~dim =
  let out__ = CArray.make t 1 in
  stubs_trapz (CArray.start out__) y x (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let trapz1 ~y ~dx ~dim =
  let out__ = CArray.make t 1 in
  stubs_trapz1 (CArray.start out__) y dx (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let triangular_solve self ~a ~upper ~transpose ~unitriangular =
  let out__ = CArray.make t 2 in
  stubs_triangular_solve
    (CArray.start out__)
    self
    a
    (if upper then 1 else 0)
    (if transpose then 1 else 0)
    (if unitriangular then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let triangular_solve_out ~x ~m self ~a ~upper ~transpose ~unitriangular =
  let out__ = CArray.make t 2 in
  stubs_triangular_solve_out
    (CArray.start out__)
    x
    m
    self
    a
    (if upper then 1 else 0)
    (if transpose then 1 else 0)
    (if unitriangular then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let tril self ~diagonal =
  let out__ = CArray.make t 1 in
  stubs_tril (CArray.start out__) self (Int64.of_int diagonal);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let tril_ self ~diagonal =
  let out__ = CArray.make t 1 in
  stubs_tril_ (CArray.start out__) self (Int64.of_int diagonal);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let tril_indices ~row ~col ~offset ~options =
  let out__ = CArray.make t 1 in
  stubs_tril_indices
    (CArray.start out__)
    (Int64.of_int row)
    (Int64.of_int col)
    (Int64.of_int offset)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let tril_out ~out self ~diagonal =
  let out__ = CArray.make t 1 in
  stubs_tril_out (CArray.start out__) out self (Int64.of_int diagonal);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let triplet_margin_loss ~anchor ~positive ~negative ~margin ~p ~eps ~swap ~reduction =
  let out__ = CArray.make t 1 in
  stubs_triplet_margin_loss
    (CArray.start out__)
    anchor
    positive
    negative
    margin
    p
    eps
    (if swap then 1 else 0)
    (Reduction.to_int reduction |> Int64.of_int);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let triu self ~diagonal =
  let out__ = CArray.make t 1 in
  stubs_triu (CArray.start out__) self (Int64.of_int diagonal);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let triu_ self ~diagonal =
  let out__ = CArray.make t 1 in
  stubs_triu_ (CArray.start out__) self (Int64.of_int diagonal);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let triu_indices ~row ~col ~offset ~options =
  let out__ = CArray.make t 1 in
  stubs_triu_indices
    (CArray.start out__)
    (Int64.of_int row)
    (Int64.of_int col)
    (Int64.of_int offset)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let triu_out ~out self ~diagonal =
  let out__ = CArray.make t 1 in
  stubs_triu_out (CArray.start out__) out self (Int64.of_int diagonal);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let true_divide self other =
  let out__ = CArray.make t 1 in
  stubs_true_divide (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let true_divide_ self other =
  let out__ = CArray.make t 1 in
  stubs_true_divide_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let true_divide_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_true_divide_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let trunc self =
  let out__ = CArray.make t 1 in
  stubs_trunc (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let trunc_ self =
  let out__ = CArray.make t 1 in
  stubs_trunc_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let trunc_out ~out self =
  let out__ = CArray.make t 1 in
  stubs_trunc_out (CArray.start out__) out self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let type_as self other =
  let out__ = CArray.make t 1 in
  stubs_type_as (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let unbind self ~dim = stubs_unbind self (Int64.of_int dim) |> to_tensor_list

let unflatten self ~dim ~sizes =
  let out__ = CArray.make t 1 in
  stubs_unflatten
    (CArray.start out__)
    self
    (Int64.of_int dim)
    (List.map Int64.of_int sizes |> CArray.of_list int64_t |> CArray.start)
    (List.length sizes);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let unflatten_dense_tensors ~flat tensors =
  stubs_unflatten_dense_tensors
    flat
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors)
  |> to_tensor_list

let unfold self ~dimension ~size ~step =
  let out__ = CArray.make t 1 in
  stubs_unfold
    (CArray.start out__)
    self
    (Int64.of_int dimension)
    (Int64.of_int size)
    (Int64.of_int step);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let unfold_backward ~grad_in ~input_sizes ~dim ~size ~step =
  let out__ = CArray.make t 1 in
  stubs_unfold_backward
    (CArray.start out__)
    grad_in
    (List.map Int64.of_int input_sizes |> CArray.of_list int64_t |> CArray.start)
    (List.length input_sizes)
    (Int64.of_int dim)
    (Int64.of_int size)
    (Int64.of_int step);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let uniform_ self ~from ~to_ =
  let out__ = CArray.make t 1 in
  stubs_uniform_ (CArray.start out__) self from to_;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let unique_consecutive self ~return_inverse ~return_counts ~dim =
  let out__ = CArray.make t 3 in
  stubs_unique_consecutive
    (CArray.start out__)
    self
    (if return_inverse then 1 else 0)
    (if return_counts then 1 else 0)
    (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let unique_dim self ~dim ~sorted ~return_inverse ~return_counts =
  let out__ = CArray.make t 3 in
  stubs_unique_dim
    (CArray.start out__)
    self
    (Int64.of_int dim)
    (if sorted then 1 else 0)
    (if return_inverse then 1 else 0)
    (if return_counts then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let unique_dim_consecutive self ~dim ~return_inverse ~return_counts =
  let out__ = CArray.make t 3 in
  stubs_unique_dim_consecutive
    (CArray.start out__)
    self
    (Int64.of_int dim)
    (if return_inverse then 1 else 0)
    (if return_counts then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  let t2 = CArray.get out__ 2 in
  Gc.finalise C.Tensor.free t2;
  t0, t1, t2

let unsafe_chunk self ~chunks ~dim =
  stubs_unsafe_chunk self (Int64.of_int chunks) (Int64.of_int dim) |> to_tensor_list

let unsafe_split self ~split_size ~dim =
  stubs_unsafe_split self (Int64.of_int split_size) (Int64.of_int dim) |> to_tensor_list

let unsafe_split_with_sizes self ~split_sizes ~dim =
  stubs_unsafe_split_with_sizes
    self
    (List.map Int64.of_int split_sizes |> CArray.of_list int64_t |> CArray.start)
    (List.length split_sizes)
    (Int64.of_int dim)
  |> to_tensor_list

let unsqueeze self ~dim =
  let out__ = CArray.make t 1 in
  stubs_unsqueeze (CArray.start out__) self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let unsqueeze_ self ~dim =
  let out__ = CArray.make t 1 in
  stubs_unsqueeze_ (CArray.start out__) self (Int64.of_int dim);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_bicubic2d self ~output_size ~align_corners ~scales_h ~scales_w =
  let out__ = CArray.make t 1 in
  stubs_upsample_bicubic2d
    (CArray.start out__)
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (if align_corners then 1 else 0)
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_bicubic2d_backward
    ~grad_output
    ~output_size
    ~input_size
    ~align_corners
    ~scales_h
    ~scales_w
  =
  let out__ = CArray.make t 1 in
  stubs_upsample_bicubic2d_backward
    (CArray.start out__)
    grad_output
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int input_size |> CArray.of_list int64_t |> CArray.start)
    (List.length input_size)
    (if align_corners then 1 else 0)
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_bicubic2d_backward_out
    ~grad_input
    ~grad_output
    ~output_size
    ~input_size
    ~align_corners
    ~scales_h
    ~scales_w
  =
  let out__ = CArray.make t 1 in
  stubs_upsample_bicubic2d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int input_size |> CArray.of_list int64_t |> CArray.start)
    (List.length input_size)
    (if align_corners then 1 else 0)
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_bicubic2d_out ~out self ~output_size ~align_corners ~scales_h ~scales_w =
  let out__ = CArray.make t 1 in
  stubs_upsample_bicubic2d_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (if align_corners then 1 else 0)
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_bilinear2d self ~output_size ~align_corners ~scales_h ~scales_w =
  let out__ = CArray.make t 1 in
  stubs_upsample_bilinear2d
    (CArray.start out__)
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (if align_corners then 1 else 0)
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_bilinear2d_backward
    ~grad_output
    ~output_size
    ~input_size
    ~align_corners
    ~scales_h
    ~scales_w
  =
  let out__ = CArray.make t 1 in
  stubs_upsample_bilinear2d_backward
    (CArray.start out__)
    grad_output
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int input_size |> CArray.of_list int64_t |> CArray.start)
    (List.length input_size)
    (if align_corners then 1 else 0)
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_bilinear2d_backward_out
    ~grad_input
    ~grad_output
    ~output_size
    ~input_size
    ~align_corners
    ~scales_h
    ~scales_w
  =
  let out__ = CArray.make t 1 in
  stubs_upsample_bilinear2d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int input_size |> CArray.of_list int64_t |> CArray.start)
    (List.length input_size)
    (if align_corners then 1 else 0)
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_bilinear2d_out ~out self ~output_size ~align_corners ~scales_h ~scales_w =
  let out__ = CArray.make t 1 in
  stubs_upsample_bilinear2d_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (if align_corners then 1 else 0)
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_linear1d self ~output_size ~align_corners ~scales =
  let out__ = CArray.make t 1 in
  stubs_upsample_linear1d
    (CArray.start out__)
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (if align_corners then 1 else 0)
    scales;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_linear1d_backward
    ~grad_output
    ~output_size
    ~input_size
    ~align_corners
    ~scales
  =
  let out__ = CArray.make t 1 in
  stubs_upsample_linear1d_backward
    (CArray.start out__)
    grad_output
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int input_size |> CArray.of_list int64_t |> CArray.start)
    (List.length input_size)
    (if align_corners then 1 else 0)
    scales;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_linear1d_backward_out
    ~grad_input
    ~grad_output
    ~output_size
    ~input_size
    ~align_corners
    ~scales
  =
  let out__ = CArray.make t 1 in
  stubs_upsample_linear1d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int input_size |> CArray.of_list int64_t |> CArray.start)
    (List.length input_size)
    (if align_corners then 1 else 0)
    scales;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_linear1d_out ~out self ~output_size ~align_corners ~scales =
  let out__ = CArray.make t 1 in
  stubs_upsample_linear1d_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (if align_corners then 1 else 0)
    scales;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_nearest1d self ~output_size ~scales =
  let out__ = CArray.make t 1 in
  stubs_upsample_nearest1d
    (CArray.start out__)
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    scales;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_nearest1d_backward ~grad_output ~output_size ~input_size ~scales =
  let out__ = CArray.make t 1 in
  stubs_upsample_nearest1d_backward
    (CArray.start out__)
    grad_output
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int input_size |> CArray.of_list int64_t |> CArray.start)
    (List.length input_size)
    scales;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_nearest1d_backward_out
    ~grad_input
    ~grad_output
    ~output_size
    ~input_size
    ~scales
  =
  let out__ = CArray.make t 1 in
  stubs_upsample_nearest1d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int input_size |> CArray.of_list int64_t |> CArray.start)
    (List.length input_size)
    scales;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_nearest1d_out ~out self ~output_size ~scales =
  let out__ = CArray.make t 1 in
  stubs_upsample_nearest1d_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    scales;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_nearest2d self ~output_size ~scales_h ~scales_w =
  let out__ = CArray.make t 1 in
  stubs_upsample_nearest2d
    (CArray.start out__)
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_nearest2d_backward ~grad_output ~output_size ~input_size ~scales_h ~scales_w =
  let out__ = CArray.make t 1 in
  stubs_upsample_nearest2d_backward
    (CArray.start out__)
    grad_output
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int input_size |> CArray.of_list int64_t |> CArray.start)
    (List.length input_size)
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_nearest2d_backward_out
    ~grad_input
    ~grad_output
    ~output_size
    ~input_size
    ~scales_h
    ~scales_w
  =
  let out__ = CArray.make t 1 in
  stubs_upsample_nearest2d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int input_size |> CArray.of_list int64_t |> CArray.start)
    (List.length input_size)
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_nearest2d_out ~out self ~output_size ~scales_h ~scales_w =
  let out__ = CArray.make t 1 in
  stubs_upsample_nearest2d_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_nearest3d self ~output_size ~scales_d ~scales_h ~scales_w =
  let out__ = CArray.make t 1 in
  stubs_upsample_nearest3d
    (CArray.start out__)
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    scales_d
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_nearest3d_backward
    ~grad_output
    ~output_size
    ~input_size
    ~scales_d
    ~scales_h
    ~scales_w
  =
  let out__ = CArray.make t 1 in
  stubs_upsample_nearest3d_backward
    (CArray.start out__)
    grad_output
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int input_size |> CArray.of_list int64_t |> CArray.start)
    (List.length input_size)
    scales_d
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_nearest3d_backward_out
    ~grad_input
    ~grad_output
    ~output_size
    ~input_size
    ~scales_d
    ~scales_h
    ~scales_w
  =
  let out__ = CArray.make t 1 in
  stubs_upsample_nearest3d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int input_size |> CArray.of_list int64_t |> CArray.start)
    (List.length input_size)
    scales_d
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_nearest3d_out ~out self ~output_size ~scales_d ~scales_h ~scales_w =
  let out__ = CArray.make t 1 in
  stubs_upsample_nearest3d_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    scales_d
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_trilinear3d self ~output_size ~align_corners ~scales_d ~scales_h ~scales_w =
  let out__ = CArray.make t 1 in
  stubs_upsample_trilinear3d
    (CArray.start out__)
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (if align_corners then 1 else 0)
    scales_d
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_trilinear3d_backward
    ~grad_output
    ~output_size
    ~input_size
    ~align_corners
    ~scales_d
    ~scales_h
    ~scales_w
  =
  let out__ = CArray.make t 1 in
  stubs_upsample_trilinear3d_backward
    (CArray.start out__)
    grad_output
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int input_size |> CArray.of_list int64_t |> CArray.start)
    (List.length input_size)
    (if align_corners then 1 else 0)
    scales_d
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_trilinear3d_backward_out
    ~grad_input
    ~grad_output
    ~output_size
    ~input_size
    ~align_corners
    ~scales_d
    ~scales_h
    ~scales_w
  =
  let out__ = CArray.make t 1 in
  stubs_upsample_trilinear3d_backward_out
    (CArray.start out__)
    grad_input
    grad_output
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (List.map Int64.of_int input_size |> CArray.of_list int64_t |> CArray.start)
    (List.length input_size)
    (if align_corners then 1 else 0)
    scales_d
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let upsample_trilinear3d_out
    ~out
    self
    ~output_size
    ~align_corners
    ~scales_d
    ~scales_h
    ~scales_w
  =
  let out__ = CArray.make t 1 in
  stubs_upsample_trilinear3d_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int output_size |> CArray.of_list int64_t |> CArray.start)
    (List.length output_size)
    (if align_corners then 1 else 0)
    scales_d
    scales_h
    scales_w;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let value_selecting_reduction_backward ~grad ~dim ~indices ~sizes ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_value_selecting_reduction_backward
    (CArray.start out__)
    grad
    (Int64.of_int dim)
    indices
    (List.map Int64.of_int sizes |> CArray.of_list int64_t |> CArray.start)
    (List.length sizes)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let values self =
  let out__ = CArray.make t 1 in
  stubs_values (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let vander ~x ~n ~increasing =
  let out__ = CArray.make t 1 in
  stubs_vander (CArray.start out__) x (Int64.of_int n) (if increasing then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let var self ~unbiased =
  let out__ = CArray.make t 1 in
  stubs_var (CArray.start out__) self (if unbiased then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let var1 self ~dim ~unbiased ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_var1
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if unbiased then 1 else 0)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let var2 self ~dim ~correction ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_var2
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (Int64.of_int correction)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let var_mean self ~unbiased =
  let out__ = CArray.make t 2 in
  stubs_var_mean (CArray.start out__) self (if unbiased then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let var_mean1 self ~dim ~unbiased ~keepdim =
  let out__ = CArray.make t 2 in
  stubs_var_mean1
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if unbiased then 1 else 0)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let var_mean2 self ~dim ~correction ~keepdim =
  let out__ = CArray.make t 2 in
  stubs_var_mean2
    (CArray.start out__)
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (Int64.of_int correction)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  let t1 = CArray.get out__ 1 in
  Gc.finalise C.Tensor.free t1;
  t0, t1

let var_out ~out self ~dim ~unbiased ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_var_out
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (if unbiased then 1 else 0)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let var_out1 ~out self ~dim ~correction ~keepdim =
  let out__ = CArray.make t 1 in
  stubs_var_out1
    (CArray.start out__)
    out
    self
    (List.map Int64.of_int dim |> CArray.of_list int64_t |> CArray.start)
    (List.length dim)
    (Int64.of_int correction)
    (if keepdim then 1 else 0);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let vdot self other =
  let out__ = CArray.make t 1 in
  stubs_vdot (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let vdot_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_vdot_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let view self ~size =
  let out__ = CArray.make t 1 in
  stubs_view
    (CArray.start out__)
    self
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let view1 self ~dtype =
  let out__ = CArray.make t 1 in
  stubs_view1 (CArray.start out__) self (Kind.packed_to_int dtype);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let view_as self other =
  let out__ = CArray.make t 1 in
  stubs_view_as (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let view_as_complex self =
  let out__ = CArray.make t 1 in
  stubs_view_as_complex (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let view_as_real self =
  let out__ = CArray.make t 1 in
  stubs_view_as_real (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let vsplit self ~sections = stubs_vsplit self (Int64.of_int sections) |> to_tensor_list

let vsplit1 self ~indices =
  stubs_vsplit1
    self
    (List.map Int64.of_int indices |> CArray.of_list int64_t |> CArray.start)
    (List.length indices)
  |> to_tensor_list

let vstack tensors =
  let out__ = CArray.make t 1 in
  stubs_vstack
    (CArray.start out__)
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let vstack_out ~out tensors =
  let out__ = CArray.make t 1 in
  stubs_vstack_out
    (CArray.start out__)
    out
    (CArray.of_list t tensors |> CArray.start)
    (List.length tensors);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let where ~condition = stubs_where condition |> to_tensor_list

let where1 ~condition self other =
  let out__ = CArray.make t 1 in
  stubs_where1 (CArray.start out__) condition self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let xlogy self other =
  let out__ = CArray.make t 1 in
  stubs_xlogy (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let xlogy_ self other =
  let out__ = CArray.make t 1 in
  stubs_xlogy_ (CArray.start out__) self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let xlogy_out ~out self other =
  let out__ = CArray.make t 1 in
  stubs_xlogy_out (CArray.start out__) out self other;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let zero_ self =
  let out__ = CArray.make t 1 in
  stubs_zero_ (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let zeros ~size ~options =
  let out__ = CArray.make t 1 in
  stubs_zeros
    (CArray.start out__)
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size)
    (Kind.packed_to_int (fst options))
    (Device.to_int (snd options));
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let zeros_like self =
  let out__ = CArray.make t 1 in
  stubs_zeros_like (CArray.start out__) self;
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0

let zeros_out ~out ~size =
  let out__ = CArray.make t 1 in
  stubs_zeros_out
    (CArray.start out__)
    out
    (List.map Int64.of_int size |> CArray.of_list int64_t |> CArray.start)
    (List.length size);
  let t0 = CArray.get out__ 0 in
  Gc.finalise C.Tensor.free t0;
  t0
